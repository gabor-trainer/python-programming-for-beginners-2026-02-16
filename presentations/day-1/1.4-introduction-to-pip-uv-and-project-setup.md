# Chapter 1.4: Introduction to pip, uv, and project setup

**Reading time**: 20 minutes  
**Topics covered**: Python packages, pip basics, uv for modern package management, pyproject.toml, project initialization  
**Prerequisite reading**: Chapter 1.3  
**Associated lab**: Lab 1.4 - Package management with pip and uv

## What you will learn

After reading this chapter, you will be able to:

- Explain what Python packages are and why they extend Python's capabilities
- Recognize pip as the traditional package manager and understand its basic usage
- Identify uv as a modern, fast alternative to pip for package management
- Write commands to initialize a project with uv and manage dependencies
- Describe the role of pyproject.toml in declaring project dependencies

## Introduction

Python's standard library provides powerful tools out of the box — file handling, date manipulation, mathematical functions, and much more. But Python's true strength lies in its ecosystem: tens of thousands of third-party packages that add specialized functionality. Need to work with Excel files? There is a package. Want to build a web API? There is a framework. Need to perform advanced data analysis? Libraries exist for that too.

These packages are distributed through the Python Package Index (PyPI), a central repository where developers publish and share their code. To use these packages, you need a **package manager** — a tool that downloads, installs, and manages dependencies.

Historically, pip has been Python's standard package manager. It works well but can be slow and requires manual dependency tracking. Recently, a new tool called **uv** emerged, offering dramatically faster installations and integrated project management. In this training, you will learn both: pip to understand the traditional approach, and uv as the modern, recommended tool.

## 1.4.1 What are Python packages?

A **package** is a collection of Python modules (code files) that someone else wrote and made available for reuse. Instead of building every feature from scratch, you install packages and use their functionality in your programs.

Consider a practical scenario: You need to make an HTTP request to retrieve data from a web API. You could write low-level socket code to connect to the server, format an HTTP request, parse the response, and handle errors. Or you could install the `requests` package and write:

```python
import requests
response = requests.get("https://api.example.com/data")
print(response.json())
```

The `requests` package handles all the complexity. You focus on your problem, not HTTP internals.

**Where packages come from:**

Most Python packages are published on **PyPI** (Python Package Index), accessible at pypi.org. PyPI hosts over 500,000 packages covering web frameworks, data science, machine learning, automation, testing, and more.

When you install a package, your package manager downloads it from PyPI and places it in a location where Python can import it.

## 1.4.2 pip: The traditional package manager

**pip** is Python's default package manager, included with every Python installation. It downloads and installs packages from PyPI.

**Installing a package with pip:**

```
C:\labs> pip install requests
```

This command downloads the `requests` package and its dependencies, then installs them. After installation, you can import the package in your code:

```python
import requests
```

**Listing installed packages:**

```
C:\labs> pip list
```

This displays all installed packages and their versions.

**Uninstalling a package:**

```
C:\labs> pip uninstall requests
```

**Why pip matters:**

pip has been the standard for over a decade. Understanding pip helps you work with older projects, read documentation, and troubleshoot issues. However, pip has limitations:

- Slow installation, especially for large packages
- No built-in project management (you manage dependencies manually)
- Requires separate tools for dependency tracking (requirements.txt files)

This is where uv comes in.

## 1.4.3 uv: Modern package and project management

**uv** is a new, fast package and project manager written by Astral (the creators of Ruff, a popular Python linter). uv performs the same tasks as pip but orders of magnitude faster. It also integrates project initialization, dependency management, and script execution into one tool.

**Key advantages of uv:**

- **Speed**: uv installs packages 10-100x faster than pip
- **Integrated workflow**: Initialize projects, add dependencies, and run scripts with one tool
- **Declarative dependencies**: Dependencies are declared in `pyproject.toml`, not manually tracked
- **Modern best practices**: Follows current Python packaging standards

From this point forward in the training, you will use uv for all package management.

## 1.4.4 Initializing a project with uv

uv introduces the concept of **project-based workflow**. Instead of installing packages globally (where they affect all scripts on your system), you create a project with its own dependencies.

**Creating a new project:**

```
C:\labs> uv init my_project
```

This command creates a directory structure:

```
my_project/
├── pyproject.toml
├── README.md
└── hello.py
```

The key file is `pyproject.toml`, which declares project metadata and dependencies.

**What is pyproject.toml?**

`pyproject.toml` is a configuration file that describes your project. It lists dependencies, project name, version, and other settings. When you add a package with uv, it updates this file automatically.

A typical `pyproject.toml` looks like:

```toml
[project]
name = "my_project"
version = "0.1.0"
description = "A sample Python project"
dependencies = []

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

The `dependencies = []` list will populate as you add packages.

## 1.4.5 Adding packages with uv

Instead of `pip install <package>`, use `uv add <package>`:

```
C:\labs\my_project> uv add requests
```

uv performs several actions:

1. Downloads and installs the `requests` package
2. Updates `pyproject.toml` to include `requests` in the dependencies list
3. Creates a virtual environment (isolated Python environment) for the project
4. Locks dependency versions in a lock file for reproducibility

After running `uv add requests`, your `pyproject.toml` updates to:

```toml
[project]
name = "my_project"
version = "0.1.0"
description = "A sample Python project"
dependencies = [
    "requests",
]
```

Now anyone who clones your project can install all dependencies by running `uv sync`.

**Why declarative dependencies matter:**

With pip, you manually track what packages you installed. If you share your code, you must remember to document dependencies. With uv and `pyproject.toml`, dependencies are explicitly declared. This prevents "works on my machine" problems.

## 1.4.6 Running scripts with uv

When you use uv, scripts run inside the project's virtual environment. Instead of `python script.py`, use `uv run script.py`:

```
C:\labs\my_project> uv run hello.py
```

This ensures the script uses the correct Python environment and has access to installed packages.

**In practice:**

Imagine you are working on a data analysis script. You initialize a project with `uv init`, add the `pandas` package with `uv add pandas`, and write your script. You run it with `uv run analyze.py`. Later, a colleague clones your project, runs `uv sync` to install dependencies, and runs `uv run analyze.py`. It works identically on their machine because all dependencies are declared and versioned.

## 1.4.7 Comparing pip and uv workflows

**Traditional pip workflow:**

1. Install packages with `pip install <package>`
2. Manually track dependencies in `requirements.txt`
3. Share the file with others
4. They run `pip install -r requirements.txt` to install

**Modern uv workflow:**

1. Initialize project with `uv init <project>`
2. Add packages with `uv add <package>` (updates `pyproject.toml` automatically)
3. Run scripts with `uv run <script.py>`
4. Share the project; others run `uv sync` to install dependencies

uv streamlines the workflow and enforces best practices.

## 1.4.8 When to use pip vs. uv

**Use pip when:**
- Working with legacy projects that use requirements.txt
- Quickly testing a package in the global environment
- Following documentation that specifies pip commands

**Use uv when:**
- Starting a new project
- Managing multiple projects with different dependencies
- Collaborating with others (declarative dependencies prevent conflicts)
- You want fast installations and modern tooling

In this training, you will use pip once to understand the traditional tool, then switch to uv for all future work.

## 1.4.9 Common pitfalls

**Using `uv pip` commands**

uv provides a `uv pip` subcommand for compatibility with pip-style workflows. Avoid it. Use `uv add` for adding dependencies, not `uv pip install`. The `uv pip` commands do not update `pyproject.toml`, defeating the purpose of declarative dependency management.

```
# WRONG
C:\labs\my_project> uv pip install requests

# CORRECT
C:\labs\my_project> uv add requests
```

**Forgetting to run scripts with `uv run`**

If you use `python script.py` inside a uv project, Python might not find the installed packages. Always use `uv run script.py` to ensure the correct environment.

```
# Might fail if packages not in global environment
C:\labs\my_project> python script.py

# Correct
C:\labs\my_project> uv run script.py
```

**Installing packages globally**

Avoid installing packages globally (outside a project). This clutters your system and causes version conflicts. Always work within a project initialized with `uv init`.

## Summary

In this chapter, you learned:

- Python packages extend functionality beyond the standard library
- PyPI is the central repository for Python packages
- pip is the traditional package manager: `pip install <package>`
- uv is a modern, fast alternative with integrated project management
- `uv init` creates a project with a `pyproject.toml` file
- `uv add <package>` installs a package and updates `pyproject.toml`
- `uv run <script.py>` executes scripts in the project's environment
- Declarative dependencies in `pyproject.toml` ensure reproducibility
- Use `uv add`, not `uv pip install`, for dependency management

**Key command patterns:**

```
# pip (traditional)
pip install requests
pip list
pip uninstall requests

# uv (modern, preferred)
uv init my_project
cd my_project
uv add requests
uv run script.py
uv sync  # Install dependencies from pyproject.toml
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 1.4: Package management with pip and uv**.

In this lab, you will:

- Install a package with pip to understand the traditional workflow
- Initialize a new project with `uv init`
- Add a dependency with `uv add` and observe how `pyproject.toml` updates
- Run a script with `uv run` that uses the installed package
- Compare the pip and uv workflows
- Understand why uv and `pyproject.toml` are the modern standard

Open your command prompt and proceed to Lab 1.4.
