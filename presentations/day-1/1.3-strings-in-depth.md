# Chapter 1.3: Strings in depth

**Reading time**: 25 minutes  
**Topics covered**: String indexing, slicing, string methods, escape characters, multi-line strings, f-string formatting  
**Prerequisite reading**: Chapter 1.2  
**Associated lab**: Lab 1.3 - String manipulation and formatting

## What you will learn

After reading this chapter, you will be able to:

- Explain how Python indexes strings and extract individual characters or substrings
- Write slicing expressions to extract portions of strings
- Identify and use common string methods for cleaning and transforming text
- Recognize escape characters and their purpose in strings
- Create multi-line strings for longer text content
- Apply f-string formatting with precision and alignment options

## Introduction

In the previous chapter, you learned that strings are one of Python's fundamental data types. You created string variables, combined them with other text, and used f-strings to embed values. But strings are far more than simple text containers — they are powerful tools for processing, validating, and formatting data.

Consider these common programming tasks: extracting a username from an email address, validating that a phone number contains only digits, converting user input to title case, or splitting a sentence into individual words. All of these operations work with strings, and Python provides rich built-in functionality to handle them cleanly.

In this chapter, you will explore strings in depth. You will learn how to access individual characters, extract substrings, transform text with methods, handle special characters, and format output precisely. By the end, you will be comfortable manipulating text data — a skill that appears in nearly every Python program.

## 1.3.1 String indexing: Accessing individual characters

A string in Python is a sequence of characters. Each character has a position, called an **index**. Python uses zero-based indexing, meaning the first character is at index 0, the second at index 1, and so on.

You access a character using square brackets `[]`:

```python
word = "Python"
first_char = word[0]   # "P"
second_char = word[1]  # "y"
last_char = word[5]    # "n"
```

The string `"Python"` has six characters. Their indices are:

```
P  y  t  h  o  n
0  1  2  3  4  5
```

Python also supports negative indexing, which counts from the end:

```python
word = "Python"
last_char = word[-1]    # "n" (last character)
second_last = word[-2]  # "o" (second from end)
first_char = word[-6]   # "P" (same as word[0])
```

Negative indices are convenient when you need the last character without calculating the length:

```
P  y  t  h  o  n
-6 -5 -4 -3 -2 -1
```

**Warning:**

Accessing an index that does not exist produces an `IndexError`:

```python
>>> word = "Python"
>>> word[10]
IndexError: string index out of range
```

Always ensure indices are within the valid range: `0` to `len(string) - 1`.

## 1.3.2 String slicing: Extracting substrings

**Slicing** extracts a portion of a string using the syntax `[start:stop]`. Python includes characters from `start` up to (but not including) `stop`:

```python
text = "Python Programming"
substring = text[0:6]  # "Python" (indices 0, 1, 2, 3, 4, 5)
```

The slice `[0:6]` starts at index 0 and stops before index 6, extracting the first six characters.

You can omit `start` to begin at the beginning, or omit `stop` to continue to the end:

```python
text = "Python Programming"
start = text[:6]      # "Python" (from beginning to index 6)
end = text[7:]        # "Programming" (from index 7 to end)
entire = text[:]      # "Python Programming" (entire string)
```

**Step parameter:**

Slicing supports a third parameter, `step`, which specifies the interval: `[start:stop:step]`

```python
text = "Python"
every_other = text[::2]   # "Pto" (every second character)
reversed_text = text[::-1]  # "nohtyP" (reversed string)
```

The step `-1` reverses the string, a common idiom in Python.

**Think about it:**

Before reading further, consider: How would you extract the domain from an email address like "alice@example.com"? What slice would give you "example.com"?

You would find the index of `@`, then slice from that position plus one to the end. Python provides string methods to make this easier, which you will learn shortly.

## 1.3.3 String methods: Transforming and analyzing text

Python strings have dozens of built-in methods that perform common operations. These methods do not modify the original string (strings are immutable) but return new strings with the transformation applied.

**Case conversion:**

```python
text = "Python Programming"
lower = text.lower()       # "python programming"
upper = text.upper()       # "PYTHON PROGRAMMING"
title = text.title()       # "Python Programming" (each word capitalized)
swapped = text.swapcase()  # "pYTHON pROGRAMMING"
```

**Whitespace removal:**

```python
text = "  hello world  "
stripped = text.strip()   # "hello world" (removes leading/trailing whitespace)
left = text.lstrip()      # "hello world  " (removes leading only)
right = text.rstrip()     # "  hello world" (removes trailing only)
```

The `strip()` method is essential when processing user input, which often contains unintended spaces.

**Splitting and joining:**

The `split()` method divides a string into a list of substrings based on a delimiter. The `join()` method combines a list of strings into one:

```python
sentence = "Python is a powerful language"
words = sentence.split()  # ["Python", "is", "a", "powerful", "language"]

csv_line = "Alice,28,Budapest"
fields = csv_line.split(",")  # ["Alice", "28", "Budapest"]

# Joining
words = ["Python", "is", "great"]
sentence = " ".join(words)  # "Python is great"
```

**Finding and replacing:**

```python
email = "alice@example.com"
at_index = email.find("@")       # 5 (index of "@")
domain_start = email.find("@") + 1
domain = email[domain_start:]    # "example.com"

# Replace text
text = "I love Java"
updated = text.replace("Java", "Python")  # "I love Python"
```

The `find()` method returns the index of the first occurrence, or `-1` if not found. The `replace()` method replaces all occurrences by default.

**Checking content:**

```python
text = "Python123"
has_digit = text.isdigit()     # False (not all characters are digits)
is_alpha = text.isalpha()      # False (contains digits)
is_alnum = text.isalnum()      # True (all characters are letters or digits)

email = "alice@example.com"
has_at = "@" in email          # True (membership check)
starts = email.startswith("alice")  # True
ends = email.endswith(".com")       # True
```

These methods are invaluable for validation. For example, checking if user input is numeric before converting it prevents errors.

**In practice:**

A common task is cleaning and validating user input. A user enters their name as "  alice  " (with extra spaces). You use `strip()` to clean it. They enter an email; you check if it contains `@` and ends with a valid domain. String methods handle these scenarios cleanly.

## 1.3.4 Escape characters and special strings

Some characters cannot be typed directly into strings — newlines, tabs, quotes. **Escape characters** use a backslash `\` followed by a character to represent these:

| Escape sequence | Meaning |
|-----------------|---------|
| `\n` | Newline (line break) |
| `\t` | Tab |
| `\\` | Backslash (literal `\`) |
| `\'` | Single quote |
| `\"` | Double quote |

The following code demonstrates escape characters:

```python
message = "Line 1\nLine 2\nLine 3"
print(message)
```

This produces:

```
Line 1
Line 2
Line 3
```

The `\n` creates line breaks. Similarly, `\t` adds horizontal spacing:

```python
data = "Name\tAge\tCity"
print(data)
```

This produces:

```
Name    Age    City
```

**Quoting strings:**

If your string contains quotes, escape them or use the opposite quote style:

```python
# Using escape
message = "She said, \"Hello!\""

# Using opposite quotes
message = 'She said, "Hello!"'
```

Both produce the same result: `She said, "Hello!"`

**Raw strings:**

For strings with many backslashes (like file paths on Windows), use a **raw string** by prefixing with `r`:

```python
# Without raw string (error-prone)
path = "C:\\Users\\Alice\\Documents"

# With raw string (cleaner)
path = r"C:\Users\Alice\Documents"
```

The `r` prefix tells Python to treat backslashes as literal characters, not escape sequences.

**Multi-line strings:**

Triple quotes (either `"""` or `'''`) create multi-line strings:

```python
description = """
Python is a high-level programming language.
It is widely used in web development, data science,
and automation.
"""
print(description)
```

This preserves line breaks, indentation, and spacing. Multi-line strings are useful for long text, SQL queries, or documentation.

## 1.3.5 f-string formatting: Advanced techniques

You learned basic f-strings in Chapter 1.2. Now let us explore advanced formatting options.

**Basic f-string syntax:**

```python
name = "Alice"
age = 28
print(f"{name} is {age} years old")
```

This produces:

```
Alice is 28 years old
```

**Formatting numbers:**

You can control decimal precision, padding, and alignment:

```python
pi = 3.14159265
print(f"Pi to 2 decimals: {pi:.2f}")  # 3.14
print(f"Pi to 4 decimals: {pi:.4f}")  # 3.1416
```

The format specifier `:.2f` means "format as a float with 2 decimal places."

**Padding and alignment:**

```python
name = "Alice"
print(f"{name:>10}")  # Right-align in 10 characters: "     Alice"
print(f"{name:<10}")  # Left-align: "Alice     "
print(f"{name:^10}")  # Center: "  Alice   "
```

You can combine alignment with padding characters:

```python
price = 49.99
print(f"${price:>8.2f}")  # "   49.99" (right-aligned, 2 decimals)
```

**Expressions inside f-strings:**

f-strings evaluate expressions directly:

```python
a = 10
b = 20
print(f"Sum: {a + b}")         # "Sum: 30"
print(f"Product: {a * b}")     # "Product: 200"
print(f"Average: {(a + b) / 2}")  # "Average: 15.0"
```

You can even call methods:

```python
name = "alice"
print(f"Capitalized: {name.upper()}")  # "Capitalized: ALICE"
```

**In practice:**

f-strings are the standard for output formatting in modern Python. They are readable, powerful, and efficient. Use them whenever you need to embed variables or expressions in strings.

## 1.3.6 Common pitfalls

**String immutability**

Strings cannot be modified in place. You cannot change a character by assignment:

```python
word = "Python"
word[0] = "J"  # TypeError: 'str' object does not support item assignment
```

Instead, create a new string:

```python
word = "Python"
word = "J" + word[1:]  # "Jython"
```

**Forgetting to save method results**

String methods return new strings; they do not modify the original:

```python
text = "  hello  "
text.strip()  # This does nothing!
print(text)   # Still "  hello  "
```

You must assign the result:

```python
text = "  hello  "
text = text.strip()
print(text)  # "hello"
```

**Off-by-one errors in slicing**

Remember that slicing excludes the `stop` index:

```python
text = "Python"
substring = text[0:3]  # "Pyt" (indices 0, 1, 2 — not 3)
```

If you want the first three characters, use `[0:3]`, not `[0:2]`.

## Summary

In this chapter, you learned:

- Strings are indexed starting at 0; negative indices count from the end
- Slicing extracts substrings with `[start:stop:step]`
- String methods like `lower()`, `upper()`, `strip()`, `split()`, `replace()`, `find()`, and membership checks transform and analyze text
- Escape characters (`\n`, `\t`, `\\`, `\'`, `\"`) represent special characters
- Raw strings (prefix `r`) treat backslashes as literals
- Multi-line strings use triple quotes (`"""` or `'''`)
- f-strings support advanced formatting: precision, alignment, padding, and embedded expressions
- Strings are immutable; methods return new strings

**Key syntax pattern:**

```python
# Indexing and slicing
first = text[0]
last = text[-1]
substring = text[3:8]
reversed = text[::-1]

# Methods
cleaned = text.strip()
words = text.split()
joined = " ".join(words)
replaced = text.replace("old", "new")

# f-string formatting
name = "Alice"
age = 28
print(f"{name} is {age} years old")
print(f"Price: ${price:.2f}")
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 1.3: String manipulation and formatting**.

In this lab, you will:

- Parse and reformat names and addresses from user input
- Extract parts of strings using slicing
- Validate input by checking for specific characters or patterns
- Clean text data with `strip()`, `lower()`, and `replace()`
- Build a formatted report using f-strings with alignment and precision
- Handle multi-line text and escape characters

Open your editor and proceed to Lab 1.3.
