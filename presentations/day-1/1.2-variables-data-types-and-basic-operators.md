# Chapter 1.2: Variables, data types, and basic operators

**Reading time**: 25 minutes  
**Topics covered**: Variables, dynamic typing, int, float, str, bool, type conversion, arithmetic and comparison operators  
**Prerequisite reading**: Chapter 1.1  
**Associated lab**: Lab 1.2 - Working with variables and operators

## What you will learn

After reading this chapter, you will be able to:

- Explain how Python stores and references data in variables
- Identify the four fundamental data types: int, float, str, and bool
- Write expressions using arithmetic, comparison, and logical operators
- Convert between data types using built-in conversion functions
- Recognize and avoid common errors related to types and operators

## Introduction

In the previous chapter, you executed simple Python expressions in the REPL. You typed `5 + 3` and received `8`. But what if you need to reuse that result later? What if you want to store a calculation, a name, or a decision and refer to it multiple times throughout your program? This is where variables come in.

Variables are fundamental to every programming language. They let you store data, give it a meaningful name, and retrieve it when needed. Python makes this remarkably simple: you choose a name, assign a value, and Python handles the rest. There are no declarations, no type annotations (unless you want them), and no memory management to worry about.

In this chapter, you will learn how Python represents different kinds of data — whole numbers, decimals, text, and true/false values. You will explore operators that let you perform calculations, compare values, and make logical decisions. By the end, you will write programs that accept user input, process it, and produce formatted results.

## 1.2.1 Variables: Storing and naming data

A **variable** is a name that refers to a value stored in memory. In Python, you create a variable with the assignment operator `=`. The name goes on the left, the value on the right:

```python
age = 28
temperature = 23.5
city = "Budapest"
is_student = True
```

Each line creates a variable. The variable `age` now holds the integer 28. The variable `temperature` holds the decimal 23.5. The variable `city` holds the text "Budapest". The variable `is_student` holds the boolean value True.

Once you create a variable, you can use it in expressions. Python substitutes the variable's value wherever the name appears:

```python
age = 28
next_year_age = age + 1
print(next_year_age)
```

This code produces:

```
29
```

Python read the value of `age` (28), added 1, and stored the result (29) in `next_year_age`. Variables let you build complex calculations step by step.

**Variable naming rules:**

Python enforces specific rules for variable names:

- Names must start with a letter (a-z, A-Z) or underscore (_)
- Names can contain letters, digits (0-9), and underscores
- Names are case-sensitive: `age`, `Age`, and `AGE` are different variables
- Names cannot be Python keywords (`if`, `for`, `while`, `def`, `class`, etc.)

**Naming conventions (PEP 8):**

While Python allows many naming styles, PEP 8 (Python's official style guide) recommends:

- Use lowercase with underscores for variable names: `user_name`, `total_price`, `is_valid`
- Use descriptive names: `age` is better than `a`, `customer_count` is better than `cc`
- Avoid single-letter names except for loop counters (`i`, `j`) or mathematical formulas (`x`, `y`)

The following examples show good and poor variable names:

```python
# Good names
user_age = 28
total_price = 49.99
is_logged_in = True

# Poor names
a = 28           # Too vague
tOtAl = 49.99    # Inconsistent capitalization
2ndvalue = 10    # Starts with digit (SyntaxError)
```

## 1.2.2 Dynamic typing: Python infers types

Python is **dynamically typed**, meaning you do not declare a variable's type. Python infers the type from the value you assign:

```python
x = 10          # x is an integer
x = "hello"     # Now x is a string
x = 3.14        # Now x is a float
```

This flexibility is powerful but requires awareness. The same variable can hold different types at different times. While convenient, it can lead to errors if you assume a variable is one type when it has become another.

You can check a variable's type with the built-in `type()` function:

```python
>>> age = 28
>>> type(age)
<class 'int'>

>>> price = 49.99
>>> type(price)
<class 'float'>

>>> name = "Alice"
>>> type(name)
<class 'str'>
```

The `type()` function returns the class (type) of the value. `int` represents integers, `float` represents floating-point numbers (decimals), and `str` represents strings (text).

**In practice:**

Dynamic typing accelerates development. You focus on solving problems, not managing type declarations. However, in large projects, dynamic typing can introduce bugs when a function expects an integer but receives a string. Tools like type hints (covered in advanced topics) help catch these issues.

## 1.2.3 The four fundamental data types

Python provides several built-in data types, but four are essential for beginners:

**1. int (integer):**

Whole numbers, positive or negative, with no decimal point:

```python
count = 10
temperature = -5
large_number = 1_000_000  # Underscores improve readability
```

Integers have unlimited precision in Python. You can work with numbers as large as memory allows.

**2. float (floating-point number):**

Numbers with decimal points:

```python
pi = 3.14159
temperature = 36.6
percentage = 0.15
```

Floats represent real numbers but have limited precision due to binary representation. This occasionally causes rounding surprises (for example, `0.1 + 0.2` equals `0.30000000000000004` instead of exactly `0.3`). For most calculations, this is negligible.

**3. str (string):**

Text data, enclosed in single or double quotes:

```python
name = "Alice"
greeting = 'Hello, World!'
address = "123 Main St, Budapest"
```

Single and double quotes work identically. Use double quotes for consistency (PEP 8 recommendation), but single quotes are fine too. Choose one style and stick with it.

**4. bool (boolean):**

Represents truth values: `True` or `False` (capitalized):

```python
is_logged_in = True
has_permission = False
```

Booleans result from comparisons and control program flow (covered in Chapter 2.3). Every value in Python has a "truthiness" — most values are considered True, but `0`, `""` (empty string), `None`, and empty collections are False.

**Key terms:**

- **Integer (int)**: Whole numbers without decimals
- **Float**: Numbers with decimal points
- **String (str)**: Sequences of characters (text)
- **Boolean (bool)**: True or False values used for logic and decision-making

## 1.2.4 Arithmetic operators

Python provides standard arithmetic operators for mathematical calculations:

| Operator | Operation | Example | Result |
|----------|-----------|---------|--------|
| `+` | Addition | `5 + 3` | `8` |
| `-` | Subtraction | `10 - 4` | `6` |
| `*` | Multiplication | `7 * 6` | `42` |
| `/` | Division (float result) | `10 / 3` | `3.3333...` |
| `//` | Floor division (integer result) | `10 // 3` | `3` |
| `%` | Modulus (remainder) | `10 % 3` | `1` |
| `**` | Exponentiation (power) | `2 ** 10` | `1024` |

The following code demonstrates each operator:

```python
# Basic arithmetic
total = 50 + 25      # 75
difference = 50 - 25  # 25
product = 50 * 2     # 100
quotient = 50 / 2    # 25.0 (always a float)

# Floor division and modulus
result = 17 // 5     # 3 (integer division, discards remainder)
remainder = 17 % 5   # 2 (the remainder when 17 is divided by 5)

# Exponentiation
power = 2 ** 8       # 256 (2 to the power of 8)
```

**Operator precedence:**

Python follows standard mathematical precedence (order of operations):

1. Parentheses `()`
2. Exponentiation `**`
3. Multiplication, Division, Floor Division, Modulus `*`, `/`, `//`, `%`
4. Addition, Subtraction `+`, `-`

The following expression evaluates according to precedence:

```python
result = 2 + 3 * 4
print(result)
```

This produces:

```
14
```

Multiplication happens first: `3 * 4 = 12`, then addition: `2 + 12 = 14`. Use parentheses to control evaluation order:

```python
result = (2 + 3) * 4
print(result)
```

This produces:

```
20
```

Now addition happens first: `2 + 3 = 5`, then multiplication: `5 * 4 = 20`.

**In practice:**

When building formulas, explicit parentheses improve readability even when not strictly required. Compare `a + b * c` versus `a + (b * c)`. The second is clearer, especially for someone reviewing your code.

## 1.2.5 Comparison and logical operators

**Comparison operators** compare two values and return a boolean (`True` or `False`):

| Operator | Meaning | Example | Result |
|----------|---------|---------|--------|
| `==` | Equal to | `5 == 5` | `True` |
| `!=` | Not equal to | `5 != 3` | `True` |
| `<` | Less than | `3 < 5` | `True` |
| `>` | Greater than | `5 > 3` | `True` |
| `<=` | Less than or equal | `5 <= 5` | `True` |
| `>=` | Greater than or equal | `5 >= 3` | `True` |

The following code demonstrates comparisons:

```python
age = 25
is_adult = age >= 18       # True (25 is greater than or equal to 18)
is_teenager = age < 18     # False (25 is not less than 18)

temperature = 30
is_hot = temperature > 25  # True
```

**Logical operators** combine boolean values:

| Operator | Meaning | Example | Result |
|----------|---------|---------|--------|
| `and` | Both must be True | `True and False` | `False` |
| `or` | At least one must be True | `True or False` | `True` |
| `not` | Inverts the boolean | `not True` | `False` |

The following code demonstrates logical operators:

```python
age = 25
has_license = True

can_drive = age >= 18 and has_license  # True (both conditions met)

is_minor = age < 18           # False
is_senior = age >= 65         # False
special_discount = is_minor or is_senior  # False (neither condition met)

is_logged_out = not True      # False
```

**Think about it:**

Before reading further, consider: What does the expression `5 > 3 and 10 < 20` evaluate to? What about `5 > 10 or 2 + 2 == 4`?

The first expression: `5 > 3` is `True`, `10 < 20` is `True`, and `True and True` equals `True`.

The second expression: `5 > 10` is `False`, `2 + 2 == 4` is `True`, and `False or True` equals `True`.

## 1.2.6 Type conversion

Sometimes you need to convert a value from one type to another. Python provides built-in functions for this:

| Function | Converts to | Example |
|----------|-------------|---------|
| `int()` | Integer | `int("42")` → `42` |
| `float()` | Float | `float("3.14")` → `3.14` |
| `str()` | String | `str(42)` → `"42"` |
| `bool()` | Boolean | `bool(1)` → `True` |

The following code demonstrates type conversion:

```python
# String to integer
age_str = "28"
age_int = int(age_str)
next_year = age_int + 1  # 29

# Integer to string
count = 100
message = "You have " + str(count) + " items"

# Float to integer (truncates decimal)
pi = 3.14
pi_int = int(pi)  # 3 (decimal part removed)
```

**Warning:**

Converting a string to a number fails if the string does not represent a valid number:

```python
>>> int("hello")
ValueError: invalid literal for int() with base 10: 'hello'
```

Always validate input before conversion, especially when accepting user input. You will learn error handling in Chapter 3.4.

## 1.2.7 Working with user input

The `input()` function reads text from the user:

```python
name = input("Enter your name: ")
print(f"Hello, {name}!")
```

When this code runs, Python displays the prompt "Enter your name: " and waits. The user types a response and presses Enter. Python stores the response in `name`.

**Important:** `input()` always returns a string. If you need a number, convert it:

```python
age_str = input("Enter your age: ")
age = int(age_str)
next_year = age + 1
print(f"Next year you will be {next_year}")
```

If the user enters "28", `age_str` contains the string `"28"`. Converting it with `int()` produces the integer `28`, which you can use in arithmetic.

**f-strings for formatted output:**

An **f-string** (formatted string literal) embeds variables directly into strings. Prefix the string with `f` and place variables inside curly braces `{}`:

```python
name = "Alice"
age = 28
print(f"{name} is {age} years old")
```

This produces:

```
Alice is 28 years old
```

f-strings are the modern, preferred way to format output in Python. They are more readable than older methods like `%` formatting or `.format()`.

## 1.2.8 Common pitfalls

**Confusing `=` and `==`**

A single `=` assigns a value. A double `==` compares values. Mixing them causes errors:

```python
# WRONG: This is an assignment, not a comparison
x = 10
if x = 10:  # SyntaxError
    print("ten")

# CORRECT: Use == for comparison
if x == 10:
    print("ten")
```

**Adding strings and numbers**

You cannot directly add a string and a number:

```python
age = 28
message = "Age: " + age  # TypeError: can only concatenate str to str
```

Convert the number to a string first:

```python
message = "Age: " + str(age)  # "Age: 28"
```

Or use an f-string:

```python
message = f"Age: {age}"  # "Age: 28"
```

**Integer division confusion**

The `/` operator always returns a float, even for whole-number results:

```python
result = 10 / 2  # 5.0 (float), not 5 (int)
```

If you need an integer result, use `//`:

```python
result = 10 // 2  # 5 (int)
```

## Summary

In this chapter, you learned:

- Variables store values and are created with the `=` assignment operator
- Python is dynamically typed: variable types are inferred from values
- The four fundamental types are `int`, `float`, `str`, and `bool`
- Arithmetic operators perform calculations: `+`, `-`, `*`, `/`, `//`, `%`, `**`
- Comparison operators return booleans: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Logical operators combine booleans: `and`, `or`, `not`
- Type conversion functions: `int()`, `float()`, `str()`, `bool()`
- `input()` reads user input as a string; convert to numbers when needed
- f-strings embed variables into strings for readable output

**Key syntax pattern:**

```python
# Variable assignment
name = "Alice"
age = 28

# Arithmetic
total = price * quantity

# Comparison
is_adult = age >= 18

# Type conversion
age = int(input("Enter your age: "))

# f-string formatting
print(f"{name} is {age} years old")
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 1.2: Working with variables and operators**.

In this lab, you will:

- Create variables of different types and inspect them with `type()`
- Perform arithmetic calculations to build a unit converter
- Use `input()` to accept user data and convert it to the correct type
- Combine strings and numbers using f-strings for formatted output
- Practice comparison and logical operators in expressions

Open VS Code and proceed to Lab 1.2.
