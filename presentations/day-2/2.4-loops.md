# Chapter 2.4: Loops

**Reading time**: 25 minutes  
**Topics covered**: for loops, range(), while loops, break, continue, nested loops, loop patterns  
**Prerequisite reading**: Chapter 2.3  
**Associated lab**: Lab 2.4 - Iteration and repetition

## What you will learn

After reading this chapter, you will be able to:

- Write `for` loops to iterate over lists, strings, and other sequences
- Use `range()` to generate sequences of numbers for counting loops
- Write `while` loops that repeat until a condition becomes false
- Control loop execution with `break` and `continue`
- Recognize when to use `for` versus `while` and avoid infinite loops

## Introduction

In Chapter 2.1, you saw that a `for` loop can process every item in a list. That was a brief preview. Loops are one of the most powerful constructs in programming — they let your code repeat actions thousands or millions of times without you writing each repetition manually.

Consider a simple task: printing the numbers 1 through 100. Without loops, you would write 100 `print()` calls. With a loop, you write two lines. Now consider a real task: processing 50,000 customer records from a file, sending an email to each one who has an overdue invoice. A loop handles this in seconds, with the same few lines of code regardless of whether there are 10 records or 10 million.

This chapter covers Python's two loop types. The `for` loop iterates over a sequence — a list, a string, a range of numbers, or any iterable object. The `while` loop repeats as long as a condition remains true. Together, they handle every repetition scenario you will encounter.

## 2.4.1 The `for` loop

The `for` loop iterates over each item in a sequence. You saw this briefly in Chapter 2.1. Here is the full pattern:

```python
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)
```

```
apple
banana
cherry
```

The variable `fruit` takes on each value in the list, one at a time. The indented block executes once per item. After the last item, the loop ends and execution continues with the next unindented line.

You can iterate over any sequence type:

**Iterating over a string (character by character):**

```python
word = "Python"
for char in word:
    print(char, end=" ")
```

```
P y t h o n
```

**Iterating over dictionary items:**

```python
prices = {"apple": 1.20, "banana": 0.80, "cherry": 3.50}
for product, price in prices.items():
    print(f"{product}: ${price:.2f}")
```

```
apple: $1.20
banana: $0.80
cherry: $3.50
```

**Accumulating a result:**

A common pattern is using a loop to build up a total:

```python
scores = [85, 92, 78, 96, 88]
total = 0
for score in scores:
    total += score

average = total / len(scores)
print(f"Average: {average:.1f}")
```

```
Average: 87.8
```

The `+=` operator adds the value on the right to the variable on the left. It is shorthand for `total = total + score`.

## 2.4.2 The `range()` function

When you need a loop that runs a specific number of times or counts through a sequence of numbers, use `range()`:

**`range(stop)` — generates numbers from 0 to stop-1:**

```python
for i in range(5):
    print(i, end=" ")
```

```
0 1 2 3 4
```

**`range(start, stop)` — generates numbers from start to stop-1:**

```python
for i in range(1, 6):
    print(i, end=" ")
```

```
1 2 3 4 5
```

**`range(start, stop, step)` — generates numbers with a custom step:**

```python
for i in range(0, 20, 5):
    print(i, end=" ")
```

```
0 5 10 15
```

You can also count backwards with a negative step:

```python
for i in range(10, 0, -1):
    print(i, end=" ")
```

```
10 9 8 7 6 5 4 3 2 1
```

**`range()` does not create a list.** It generates numbers one at a time, which makes it memory-efficient even for large ranges. `range(1_000_000)` uses almost no memory, while a list of a million numbers would consume megabytes.

**In practice:**

`range()` is essential for tasks where you need a counter: processing items by index, generating numbered output, running a block of code a fixed number of times, or building sequences of values. Combined with `len()`, it lets you access list elements by index:

```python
names = ["Alice", "Bob", "Charlie"]
for i in range(len(names)):
    print(f"Student {i + 1}: {names[i]}")
```

However, when you need both the index and the value, `enumerate()` (from Chapter 2.1) is cleaner:

```python
for i, name in enumerate(names, start=1):
    print(f"Student {i}: {name}")
```

Both produce the same output, but `enumerate()` is more readable and considered more Pythonic.

## 2.4.3 The `while` loop

The `while` loop repeats as long as its condition is `True`:

```python
count = 1
while count <= 5:
    print(count)
    count += 1
```

```
1
2
3
4
5
```

The structure is: the keyword `while`, followed by a condition, followed by a colon. The body executes repeatedly. Before each iteration, Python re-evaluates the condition. When it becomes `False`, the loop stops.

**A practical example — user input loop:**

```python
while True:
    password = input("Enter password: ")
    if password == "secret123":
        print("Access granted.")
        break
    print("Wrong password. Try again.")
```

This loop runs indefinitely (`while True`) and relies on `break` to exit when the correct password is entered. You will learn about `break` in the next section.

**Think about it:**

What happens if the condition in a `while` loop never becomes `False`? Consider `while True:` with no `break` statement inside. The loop runs forever — this is called an **infinite loop**. If your program appears frozen, an infinite loop is a likely cause. Press `Ctrl+C` in the terminal to stop it.

## 2.4.4 `for` vs. `while`: Choosing the right loop

The choice between `for` and `while` depends on whether you know in advance how many iterations you need:

| Situation | Use |
|-----------|-----|
| Iterating over a collection (list, dict, string) | `for` |
| Running a fixed number of times | `for` with `range()` |
| Repeating until a condition changes | `while` |
| Waiting for user input | `while` |
| Reading data until end-of-file | `while` |

**General guideline:** Use `for` when you know the sequence or count in advance. Use `while` when the number of iterations depends on something that changes during execution.

In practice, `for` loops are far more common than `while` loops. Most tasks involve processing a collection or repeating a known number of times. `while` loops are reserved for situations where you genuinely do not know when to stop — user interaction, network polling, or searching for a condition.

## 2.4.5 `break` and `continue`

Two keywords let you control the flow inside a loop:

**`break` — exit the loop immediately:**

```python
numbers = [4, 7, 2, 9, 1, 5]
for num in numbers:
    if num == 9:
        print("Found 9!")
        break
    print(f"Checking {num}...")
```

```
Checking 4...
Checking 7...
Checking 2...
Found 9!
```

When `break` executes, the loop ends immediately. No further iterations occur. The program continues with the first line after the loop.

**`continue` — skip to the next iteration:**

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
for num in numbers:
    if num % 2 == 0:
        continue
    print(num, end=" ")
```

```
1 3 5 7 9
```

When `continue` executes, the rest of the current iteration is skipped. The loop jumps to the next item immediately. Here, even numbers are skipped and only odd numbers are printed.

**`break` with `while` loops:**

The `break` keyword is especially common in `while True` loops to create a clean exit point:

```python
while True:
    text = input("Enter a command (quit to exit): ")
    if text == "quit":
        print("Goodbye.")
        break
    print(f"You entered: {text}")
```

This pattern — `while True` with a `break` condition — is the standard approach for interactive programs that run until the user decides to stop.

**Tip:**

Use `break` and `continue` sparingly. Too many control flow changes inside a loop make the logic hard to follow. If you find yourself needing multiple `break` or `continue` statements, consider restructuring the loop or extracting logic into a function.

## 2.4.6 Nested loops

You can place a loop inside another loop. The inner loop runs completely for each iteration of the outer loop:

```python
for row in range(1, 4):
    for col in range(1, 4):
        print(f"({row},{col})", end=" ")
    print()  # New line after each row
```

```
(1,1) (1,2) (1,3)
(2,1) (2,2) (2,3)
(3,1) (3,2) (3,3)
```

The outer loop runs 3 times (rows 1, 2, 3). For each row, the inner loop runs 3 times (columns 1, 2, 3). The total number of print operations is 3 * 3 = 9.

**A practical example — multiplication table:**

```python
print("    ", end="")
for col in range(1, 6):
    print(f"{col:4}", end="")
print()
print("   " + "----" * 5)

for row in range(1, 6):
    print(f"{row:2} |", end="")
    for col in range(1, 6):
        print(f"{row * col:4}", end="")
    print()
```

```
       1   2   3   4   5
   --------------------
 1 |   1   2   3   4   5
 2 |   2   4   6   8  10
 3 |   3   6   9  12  15
 4 |   4   8  12  16  20
 5 |   5  10  15  20  25
```

**Searching through a list of dictionaries:**

Nested loops are often used to search structured data:

```python
employees = [
    {"name": "Alice", "department": "Engineering"},
    {"name": "Bob", "department": "Marketing"},
    {"name": "Charlie", "department": "Engineering"},
    {"name": "Diana", "department": "Sales"},
]

department = "Engineering"
print(f"Employees in {department}:")
for employee in employees:
    if employee["department"] == department:
        print(f"  - {employee['name']}")
```

```
Employees in Engineering:
  - Alice
  - Charlie
```

This example uses a single loop with a conditional, not true nesting, but the pattern of filtering structured data is one of the most common loop tasks in real applications.

## 2.4.7 Common loop patterns

Several patterns appear repeatedly in Python programs:

**Building a filtered list:**

```python
numbers = [12, 45, 7, 23, 56, 89, 3, 67]
large_numbers = []
for num in numbers:
    if num > 20:
        large_numbers.append(num)
print(large_numbers)  # [45, 23, 56, 89, 67]
```

**Finding the maximum value:**

```python
temperatures = [22.5, 19.0, 25.3, 18.7, 27.1]
highest = temperatures[0]
for temp in temperatures[1:]:
    if temp > highest:
        highest = temp
print(f"Highest temperature: {highest}")  # 27.1
```

Python provides the built-in `max()` function for this, but understanding the manual approach helps you write custom search logic.

**Counting items that match a condition:**

```python
words = ["apple", "banana", "avocado", "cherry", "apricot"]
count = 0
for word in words:
    if word.startswith("a"):
        count += 1
print(f"Words starting with 'a': {count}")  # 3
```

**In practice:**

These patterns — filtering, searching, accumulating, counting — are the building blocks of data processing. Whether you are analyzing log files, processing user records, or generating reports, you will combine loops with conditionals to extract the information you need. In Chapter 4.1, you will learn list comprehensions, which provide a more concise syntax for many of these patterns.

## 2.4.8 Common pitfalls

**Infinite loops**

If the condition in a `while` loop never becomes `False`, the loop runs forever. The most common cause is forgetting to update the variable that the condition depends on:

```python
# This is WRONG — infinite loop
count = 1
while count <= 5:
    print(count)
    # Missing: count += 1
```

If you run this, the program prints `1` forever. Press `Ctrl+C` to stop it. Always ensure that something inside the loop moves it toward termination.

**Off-by-one errors with `range()`**

`range(5)` produces `0, 1, 2, 3, 4` — it stops before 5. If you want 1 through 5, use `range(1, 6)`:

```python
# Want: 1, 2, 3, 4, 5
for i in range(5):
    print(i, end=" ")    # 0 1 2 3 4 (not what we wanted)

for i in range(1, 6):
    print(i, end=" ")    # 1 2 3 4 5 (correct)
```

**Modifying a list while iterating**

As mentioned in Chapter 2.1, removing items from a list during a `for` loop can skip elements:

```python
# This is WRONG
items = [1, 2, 3, 4, 5]
for item in items:
    if item % 2 == 0:
        items.remove(item)  # Skips elements
```

Build a new list instead, or iterate over a copy:

```python
# Build a new list (preferred)
items = [1, 2, 3, 4, 5]
odd_items = [item for item in items if item % 2 != 0]
```

**Using `break` when you mean `continue` (or vice versa)**

`break` exits the loop entirely. `continue` skips to the next iteration. Confusing them produces very different behavior:

```python
# break: stops after finding first even number
for n in [1, 2, 3, 4, 5]:
    if n % 2 == 0:
        break
    print(n)
# Output: 1

# continue: skips even numbers, prints all odd ones
for n in [1, 2, 3, 4, 5]:
    if n % 2 == 0:
        continue
    print(n)
# Output: 1 3 5
```

## Summary

In this chapter, you learned:

- `for` loops iterate over sequences (lists, strings, dictionaries, ranges)
- `range(start, stop, step)` generates sequences of numbers for counting loops
- `while` loops repeat as long as a condition remains `True`
- `break` exits a loop immediately; `continue` skips to the next iteration
- Use `for` when the number of iterations is known; use `while` when it depends on runtime conditions
- Nested loops run the inner loop completely for each iteration of the outer loop
- Common patterns include filtering, accumulating, counting, and searching

**Key syntax patterns:**

```python
# for loop over a collection
for item in collection:
    process(item)

# for loop with range
for i in range(start, stop):
    print(i)

# while loop
while condition:
    do_something()

# while True with break
while True:
    data = input("Enter value: ")
    if data == "quit":
        break
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 2.4: Iteration and repetition**.

In this lab, you will:

- Process lists of data with `for` loops and accumulate results
- Implement a number-guessing game using a `while` loop
- Use nested loops to print formatted patterns
- Search through a list of dictionaries to find matching records
- Practice `break` and `continue` to control loop execution

Open VS Code and proceed to Lab 2.4.
