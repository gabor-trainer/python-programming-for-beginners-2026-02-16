# Chapter 2.3: Conditional statements

**Reading time**: 25 minutes  
**Topics covered**: if/elif/else, comparison operators, logical operators, truthiness, nested conditions  
**Prerequisite reading**: Chapter 2.2  
**Associated lab**: Lab 2.3 - Making decisions in code

## What you will learn

After reading this chapter, you will be able to:

- Write `if`, `elif`, and `else` statements to control program flow
- Use comparison operators to evaluate conditions
- Combine conditions with `and`, `or`, and `not`
- Explain how Python determines the truthiness of different values
- Write clean, readable conditional logic that avoids common mistakes

## Introduction

Every program you have written so far runs straight through, top to bottom: every line executes in order, every time. Real programs do not work this way. A login system must check whether the password is correct. An online store must calculate different shipping costs based on the destination. A weather application must display different messages depending on the temperature.

**Conditional statements** let your program make decisions. Based on a condition — is the temperature above 30? is the password correct? is the list empty? — your code takes one path or another. This is the foundation of all program logic. Without conditionals, programs are simple calculators; with them, programs become intelligent tools that respond to data.

In this chapter, you will learn Python's conditional syntax: `if`, `elif`, and `else`. You will use comparison and logical operators to express conditions, and you will explore how Python evaluates truthiness. By the end, you will write programs that make decisions based on user input and data.

## 2.3.1 The `if` statement

The `if` statement is the simplest form of conditional logic. It runs a block of code only when a condition is true:

```python
temperature = 35

if temperature > 30:
    print("It is hot outside.")
    print("Consider staying hydrated.")
```

```
It is hot outside.
Consider staying hydrated.
```

The structure is: the keyword `if`, followed by a condition, followed by a colon. The indented lines below are the **body** — they execute only when the condition evaluates to `True`. If the condition is `False`, the body is skipped entirely.

```python
temperature = 20

if temperature > 30:
    print("It is hot outside.")

print("Have a nice day.")
```

```
Have a nice day.
```

The `print("It is hot outside.")` line did not execute because `20 > 30` is `False`. The last line always runs because it is not indented under the `if` — it is outside the conditional block.

**Indentation matters.** Python uses indentation (4 spaces) to define which lines belong to the `if` block. Every line at the same indentation level is part of the block. A line at the original indentation level is no longer inside the block:

```python
if temperature > 30:
    print("Line 1 — inside the if block")
    print("Line 2 — also inside the if block")
print("Line 3 — outside the if block, always runs")
```

## 2.3.2 Comparison operators

Conditions use comparison operators to produce `True` or `False` values:

| Operator | Meaning | Example | Result |
|----------|---------|---------|--------|
| `==` | Equal to | `5 == 5` | `True` |
| `!=` | Not equal to | `5 != 3` | `True` |
| `<` | Less than | `3 < 5` | `True` |
| `>` | Greater than | `5 > 3` | `True` |
| `<=` | Less than or equal | `5 <= 5` | `True` |
| `>=` | Greater than or equal | `5 >= 6` | `False` |

You can compare any values of the same type:

```python
name = "Alice"
print(name == "Alice")   # True
print(name == "alice")   # False (case-sensitive)
print(name != "Bob")     # True

age = 28
print(age >= 18)         # True
print(age < 18)          # False
```

String comparisons are case-sensitive. `"Alice"` and `"alice"` are not equal. If you need case-insensitive comparison, convert both strings to the same case first:

```python
user_input = "alice"
if user_input.lower() == "alice":
    print("Welcome, Alice!")
```

**Warning:**

Do not confuse `=` (assignment) with `==` (comparison). A single `=` stores a value. A double `==` checks equality. Writing `if x = 5:` is a syntax error in Python. You need `if x == 5:`.

## 2.3.3 The `if`/`else` statement

The `else` clause provides an alternative block that runs when the condition is `False`:

```python
age = 15

if age >= 18:
    print("You are eligible to vote.")
else:
    print("You are not yet eligible to vote.")
```

```
You are not yet eligible to vote.
```

Exactly one of the two blocks will execute — never both, never neither. This guarantees that your program handles both cases.

A practical example — checking user input:

```python
password = input("Enter password: ")

if password == "secret123":
    print("Access granted.")
else:
    print("Access denied.")
```

## 2.3.4 The `if`/`elif`/`else` chain

When you need to check multiple conditions in sequence, use `elif` (short for "else if"):

```python
score = 85

if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
elif score >= 70:
    grade = "C"
elif score >= 60:
    grade = "D"
else:
    grade = "F"

print(f"Score: {score}, Grade: {grade}")
```

```
Score: 85, Grade: B
```

Python evaluates conditions from top to bottom and executes the first block whose condition is `True`. All remaining conditions are skipped. In this example, `85 >= 90` is `False`, so Python moves to the next condition. `85 >= 80` is `True`, so the grade is set to "B" and the rest of the chain is skipped.

**Key rules:**

- Every chain starts with `if`
- You can have zero or more `elif` clauses
- The `else` clause is optional and handles everything not caught above
- Only one block in the entire chain executes

**In practice:**

The `if`/`elif`/`else` pattern is the standard approach for menu systems, grade calculators, status categorization, and any logic where a value maps to one of several categories. The order of conditions matters — place more specific conditions before more general ones.

## 2.3.5 Logical operators: Combining conditions

Python provides three logical operators to combine conditions:

| Operator | Meaning | Example |
|----------|---------|---------|
| `and` | Both must be True | `age >= 18 and age <= 65` |
| `or` | At least one must be True | `day == "Saturday" or day == "Sunday"` |
| `not` | Reverses the truth value | `not is_logged_in` |

**`and` — both conditions must be true:**

```python
age = 25
has_license = True

if age >= 18 and has_license:
    print("You can drive.")
```

```
You can drive.
```

**`or` — at least one condition must be true:**

```python
day = "Saturday"

if day == "Saturday" or day == "Sunday":
    print("It is the weekend.")
```

```
It is the weekend.
```

**`not` — reverses the condition:**

```python
is_raining = False

if not is_raining:
    print("No umbrella needed.")
```

```
No umbrella needed.
```

You can combine multiple operators. Use parentheses to make the logic clear:

```python
temperature = 22
is_sunny = True

if temperature > 20 and (is_sunny or not is_raining):
    print("Good weather for a walk.")
```

**Tip:**

When conditions become complex, break them into named variables for readability:

```python
is_eligible_age = age >= 18 and age <= 65
has_required_documents = has_license and has_id
can_apply = is_eligible_age and has_required_documents

if can_apply:
    print("Application accepted.")
```

This is more readable than cramming everything into one `if` statement.

## 2.3.6 Truthiness and falsiness

Python evaluates not just comparisons as True or False — every value has an inherent **truthiness**. When you use a value directly in an `if` statement, Python converts it to a boolean.

**Falsy values** (evaluate to `False`):

| Value | Type |
|-------|------|
| `False` | bool |
| `0` | int |
| `0.0` | float |
| `""` | str (empty string) |
| `[]` | list (empty list) |
| `{}` | dict (empty dictionary) |
| `set()` | set (empty set) |
| `None` | NoneType |

**Everything else is truthy** — non-zero numbers, non-empty strings, non-empty collections.

This lets you write concise conditions:

```python
name = input("Enter your name: ")

if name:
    print(f"Hello, {name}!")
else:
    print("You did not enter a name.")
```

If the user presses Enter without typing anything, `name` is `""` (empty string), which is falsy. The `else` block runs. If they type any text, `name` is truthy and the greeting prints.

The same pattern works with lists:

```python
items = []

if items:
    print(f"You have {len(items)} items.")
else:
    print("Your list is empty.")
```

```
Your list is empty.
```

**Think about it:**

Consider the expression `if my_list:` versus `if len(my_list) > 0:`. Both check whether a list is non-empty. Which is more Pythonic? Why might the shorter form be preferred?

The answer: `if my_list:` is the Pythonic way. It is shorter, reads naturally ("if my list has items"), and avoids an unnecessary function call. Python developers expect this idiom.

## 2.3.7 Nested conditionals

You can place `if` statements inside other `if` statements to handle multi-level decisions:

```python
has_account = True
is_verified = False

if has_account:
    if is_verified:
        print("Full access granted.")
    else:
        print("Please verify your email first.")
else:
    print("Please create an account.")
```

```
Please verify your email first.
```

However, deeply nested conditionals quickly become difficult to read. When you find yourself nesting three or more levels, consider restructuring the logic:

```python
# Instead of deep nesting, use early returns or combined conditions
if not has_account:
    print("Please create an account.")
elif not is_verified:
    print("Please verify your email first.")
else:
    print("Full access granted.")
```

This flat structure is easier to follow. Each condition handles one case, and the logic flows linearly from top to bottom.

**Tip:**

A common technique is the "early exit" pattern: check for invalid or special cases first, handle them, and leave the main logic unindented. You will use this extensively when writing functions in Chapter 3.1.

## 2.3.8 Practical example: A simple menu system

Combining what you have learned, here is a complete example that uses conditionals to build a command-line menu:

```python
print("=== Temperature Converter ===")
print("1. Celsius to Fahrenheit")
print("2. Fahrenheit to Celsius")
print()

choice = input("Select option (1 or 2): ")

if choice == "1":
    celsius = float(input("Enter temperature in Celsius: "))
    fahrenheit = celsius * 9 / 5 + 32
    print(f"{celsius}°C = {fahrenheit:.1f}°F")
elif choice == "2":
    fahrenheit = float(input("Enter temperature in Fahrenheit: "))
    celsius = (fahrenheit - 32) * 5 / 9
    print(f"{fahrenheit}°F = {celsius:.1f}°C")
else:
    print("Invalid option. Please enter 1 or 2.")
```

This program:
1. Displays a menu with two options
2. Reads the user's choice as a string
3. Uses `if`/`elif`/`else` to handle each option or reject invalid input
4. Performs the appropriate conversion and displays the result

Notice that `choice` is a string (from `input()`), so we compare it with `"1"` and `"2"`, not with integers `1` and `2`.

## 2.3.9 Common pitfalls

**Missing the colon**

Every `if`, `elif`, and `else` line must end with a colon. Forgetting it produces a `SyntaxError`:

```python
# This is WRONG
if temperature > 30
    print("Hot")

# This is correct
if temperature > 30:
    print("Hot")
```

**Incorrect indentation**

Python uses indentation to determine which lines belong to a block. Mixing indentation levels or using inconsistent spacing causes `IndentationError`:

```python
# This is WRONG — inconsistent indentation
if temperature > 30:
    print("Hot")
      print("Stay hydrated")  # IndentationError

# This is correct
if temperature > 30:
    print("Hot")
    print("Stay hydrated")
```

**Using `=` instead of `==`**

A single `=` assigns a value; it does not compare. Python raises a `SyntaxError` if you use `=` in a condition:

```python
# This is WRONG
if status = "active":    # SyntaxError
    print("Active")

# This is correct
if status == "active":
    print("Active")
```

**Chained comparisons that look correct but behave unexpectedly**

Python supports chained comparisons, which can sometimes surprise beginners:

```python
x = 5
if 1 < x < 10:
    print("x is between 1 and 10")  # This works as expected
```

This is equivalent to `1 < x and x < 10`. Python evaluates chained comparisons correctly, but be sure you intend the chaining — `a == b == c` checks if all three are equal, not if `a == b` is equal to `c`.

## Summary

In this chapter, you learned:

- `if` executes code only when a condition is `True`
- `elif` checks additional conditions when previous ones were `False`
- `else` handles the case when no previous condition matched
- Comparison operators (`==`, `!=`, `<`, `>`, `<=`, `>=`) produce boolean values
- Logical operators (`and`, `or`, `not`) combine or invert conditions
- Falsy values (`0`, `""`, `[]`, `None`) evaluate to `False` in conditions; everything else is truthy
- Flat `if`/`elif`/`else` chains are clearer than deeply nested conditionals

**Key syntax patterns:**

```python
# Basic if/elif/else
if condition_a:
    # runs when condition_a is True
elif condition_b:
    # runs when condition_a is False and condition_b is True
else:
    # runs when all conditions are False

# Combined conditions
if age >= 18 and has_license:
    print("Allowed")

# Truthiness check
if my_list:
    print("List has items")
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 2.3: Making decisions in code**.

In this lab, you will:

- Build a grade calculator that maps scores to letter grades
- Create a command-line menu system with multiple options
- Write input validation logic that checks and rejects bad input
- Combine multiple conditions to implement business rules
- Handle edge cases with well-structured conditional chains

Open VS Code and proceed to Lab 2.3.
