# Chapter 2.2: Dictionaries and sets

**Reading time**: 25 minutes  
**Topics covered**: Dictionary creation, key-value access, dictionary methods, iteration, sets, set operations  
**Prerequisite reading**: Chapter 2.1  
**Associated lab**: Lab 2.2 - Dictionaries and sets in practice

## What you will learn

After reading this chapter, you will be able to:

- Create dictionaries and access values by key
- Add, update, and remove key-value pairs
- Iterate over dictionary keys, values, and items
- Use `.get()` for safe access when a key might not exist
- Create sets and perform union, intersection, and difference operations

## Introduction

In the previous chapter, you learned to store ordered collections in lists and tuples. Lists are powerful, but they have a limitation: to find a specific item, you need to know its index or search through the entire list. If you have a list of 10,000 customer records and need to find Alice's phone number, Python must check each entry one by one until it finds a match.

**Dictionaries** solve this problem. A dictionary maps **keys** to **values**, letting you look up data instantly by name rather than by position. Think of a real dictionary: you look up a word (the key) and find its definition (the value). Python dictionaries work the same way — you look up a key and get its associated value in a single step, regardless of how large the dictionary is.

This chapter also introduces **sets**, which store collections of unique items. Sets are ideal when you need to eliminate duplicates or perform mathematical operations like finding common elements between two groups.

## 2.2.1 Creating dictionaries

A **dictionary** is a collection of key-value pairs enclosed in curly braces. Each pair is written as `key: value`, separated by commas:

```python
contact = {
    "name": "Alice",
    "email": "alice@example.com",
    "phone": "+36 30 123 4567",
}
```

Keys are typically strings, but they can be any immutable type (strings, numbers, tuples). Values can be any type at all, including lists, other dictionaries, or booleans.

```python
student = {
    "name": "Bob",
    "age": 22,
    "grades": [85, 92, 78],
    "is_active": True,
}
```

You can also create an empty dictionary and add entries later:

```python
inventory = {}
```

The `len()` function returns the number of key-value pairs:

```python
contact = {"name": "Alice", "email": "alice@example.com"}
print(len(contact))  # 2
```

## 2.2.2 Accessing values

To retrieve a value, use the key in square brackets:

```python
contact = {"name": "Alice", "email": "alice@example.com", "phone": "+36 30 123 4567"}
print(contact["name"])    # Alice
print(contact["email"])   # alice@example.com
```

If the key does not exist, Python raises a `KeyError`:

```python
print(contact["address"])  # KeyError: 'address'
```

**Safe access with `.get()`:**

The `.get()` method returns the value if the key exists, or a default value if it does not. This avoids `KeyError` entirely:

```python
print(contact.get("name"))           # Alice
print(contact.get("address"))        # None
print(contact.get("address", "N/A")) # N/A
```

The second argument to `.get()` is the default value returned when the key is missing. If you omit it, the default is `None`.

**Think about it:**

You are building an application that reads configuration from a dictionary. Some settings are optional — the user may or may not provide them. Which approach is safer: `config["timeout"]` or `config.get("timeout", 30)`? What happens with each if the key is missing?

## 2.2.3 Adding, updating, and removing entries

**Adding and updating:**

Assign a value to a key. If the key exists, the value is updated. If it does not exist, a new entry is created:

```python
contact = {"name": "Alice", "email": "alice@example.com"}

contact["phone"] = "+36 30 123 4567"  # Add new key
contact["email"] = "alice@newmail.com" # Update existing key
print(contact)
```

```
{'name': 'Alice', 'email': 'alice@newmail.com', 'phone': '+36 30 123 4567'}
```

You can also merge another dictionary using the `update()` method:

```python
contact = {"name": "Alice"}
extra = {"email": "alice@example.com", "age": 28}
contact.update(extra)
print(contact)  # {'name': 'Alice', 'email': 'alice@example.com', 'age': 28}
```

**Removing entries:**

```python
contact = {"name": "Alice", "email": "alice@example.com", "phone": "+36 30 123 4567"}

del contact["phone"]             # Remove by key
print(contact)                   # {'name': 'Alice', 'email': 'alice@example.com'}

email = contact.pop("email")     # Remove and return value
print(email)                     # alice@example.com
print(contact)                   # {'name': 'Alice'}
```

Like lists, `del` removes an entry permanently. The `pop()` method removes the entry and returns its value, which is useful when you need to process the removed data.

**Warning:**

Using `del` or `pop()` with a key that does not exist raises a `KeyError`. Use `in` to check first, or use `pop()` with a default: `contact.pop("address", None)`.

## 2.2.4 Checking membership

The `in` operator checks whether a key exists in the dictionary:

```python
contact = {"name": "Alice", "email": "alice@example.com"}
print("name" in contact)     # True
print("phone" in contact)    # False
print("phone" not in contact)  # True
```

Note that `in` checks **keys**, not values. To check if a value exists, use the `.values()` method:

```python
print("Alice" in contact.values())  # True
```

## 2.2.5 Iterating over dictionaries

Dictionaries support three iteration patterns:

**Iterating over keys (default):**

```python
contact = {"name": "Alice", "email": "alice@example.com", "age": 28}
for key in contact:
    print(key)
```

```
name
email
age
```

**Iterating over values:**

```python
for value in contact.values():
    print(value)
```

```
Alice
alice@example.com
28
```

**Iterating over key-value pairs:**

```python
for key, value in contact.items():
    print(f"{key}: {value}")
```

```
name: Alice
email: alice@example.com
age: 28
```

The `.items()` method returns pairs of (key, value) that you can unpack into two variables, just like tuple unpacking from Chapter 2.1.

**In practice:**

Iterating over `.items()` is the most common pattern when you need both the key and the value. For example, displaying a contact record, building a formatted report, or processing configuration settings all use this pattern.

## 2.2.6 Practical example: Word frequency counter

Dictionaries are ideal for counting occurrences. The following program counts how often each word appears in a text:

```python
text = "the cat sat on the mat the cat"
words = text.split()

frequency = {}
for word in words:
    if word in frequency:
        frequency[word] += 1
    else:
        frequency[word] = 1

for word, count in frequency.items():
    print(f"{word}: {count}")
```

```
the: 3
cat: 2
sat: 1
on: 1
mat: 1
```

This pattern — check if the key exists, then update or create — is so common that Python provides a shortcut with `.get()`:

```python
frequency = {}
for word in words:
    frequency[word] = frequency.get(word, 0) + 1
```

The `frequency.get(word, 0)` returns the current count if the word exists, or `0` if it is new. Either way, we add 1 and store the result. This single line replaces the entire `if`/`else` block.

## 2.2.7 Sets: Collections of unique items

A **set** is an unordered collection that contains no duplicate elements. You create a set with curly braces or the `set()` function:

```python
colors = {"red", "green", "blue"}
numbers = {1, 2, 3, 2, 1}
print(numbers)  # {1, 2, 3}  (duplicates removed automatically)
```

Sets are useful when you need to:
- Eliminate duplicates from a list
- Test membership efficiently
- Find common or different elements between groups

**Creating a set from a list (removing duplicates):**

```python
names = ["Alice", "Bob", "Alice", "Charlie", "Bob"]
unique_names = set(names)
print(unique_names)  # {'Alice', 'Bob', 'Charlie'}
```

**Note:**

To create an empty set, you must use `set()`, not `{}`. Empty curly braces `{}` create an empty dictionary, not an empty set. This is a common source of confusion.

## 2.2.8 Set operations

Sets support mathematical operations that are useful for comparing groups of data.

**Adding and removing elements:**

```python
colors = {"red", "green", "blue"}
colors.add("yellow")
colors.discard("green")   # Remove if present (no error if missing)
print(colors)              # {'red', 'blue', 'yellow'}
```

Use `discard()` instead of `remove()` when you are not sure the element exists. `remove()` raises a `KeyError` if the element is missing; `discard()` does nothing.

**Union — all elements from both sets:**

```python
frontend = {"HTML", "CSS", "JavaScript"}
backend = {"Python", "SQL", "JavaScript"}

all_skills = frontend | backend
print(all_skills)  # {'HTML', 'CSS', 'JavaScript', 'Python', 'SQL'}
```

**Intersection — elements present in both sets:**

```python
common = frontend & backend
print(common)  # {'JavaScript'}
```

**Difference — elements in one set but not the other:**

```python
frontend_only = frontend - backend
print(frontend_only)  # {'HTML', 'CSS'}

backend_only = backend - frontend
print(backend_only)   # {'Python', 'SQL'}
```

**Symmetric difference — elements in either set but not both:**

```python
exclusive = frontend ^ backend
print(exclusive)  # {'HTML', 'CSS', 'Python', 'SQL'}
```

The following table summarizes set operations:

| Operation | Operator | Method | Result |
|-----------|----------|--------|--------|
| Union | `a \| b` | `a.union(b)` | All elements from both |
| Intersection | `a & b` | `a.intersection(b)` | Elements in both |
| Difference | `a - b` | `a.difference(b)` | Elements in a but not b |
| Symmetric difference | `a ^ b` | `a.symmetric_difference(b)` | Elements in either but not both |

**In practice:**

A common real-world use case: you have a list of users who registered for a webinar and a list of users who actually attended. Using set intersection, you can instantly find who attended. Using set difference, you find who registered but did not show up. These operations would require nested loops with lists but are one-line operations with sets.

## 2.2.9 Choosing the right data structure

You now know four core data structures. Choosing the right one depends on what you need:

| Need | Data structure | Why |
|------|---------------|-----|
| Ordered collection that changes | List | Mutable, indexed, supports append/remove |
| Fixed record of related fields | Tuple | Immutable, clear intent, tuple unpacking |
| Key-value lookup | Dictionary | Instant access by key, flexible values |
| Unique elements, no duplicates | Set | Automatic deduplication, fast membership test |

As a general guideline: if you need to look something up by a name or label, use a dictionary. If you need an ordered sequence of similar items, use a list. If you need to ensure uniqueness, use a set. If you need an immutable record, use a tuple.

## 2.2.10 Common pitfalls

**Using a mutable type as a dictionary key**

Dictionary keys must be immutable. Lists cannot be keys, but tuples can:

```python
# This is WRONG — lists are mutable
locations = {[47.5, 19.0]: "Budapest"}  # TypeError: unhashable type: 'list'

# This is correct — tuples are immutable
locations = {(47.5, 19.0): "Budapest"}
```

**Confusing `{}` for an empty set**

Empty curly braces create a dictionary, not a set:

```python
empty_dict = {}     # This is a dictionary
empty_set = set()   # This is a set

print(type(empty_dict))  # <class 'dict'>
print(type(empty_set))   # <class 'set'>
```

**Modifying a dictionary while iterating over it**

Adding or removing keys during iteration raises a `RuntimeError`:

```python
# This is WRONG
data = {"a": 1, "b": 2, "c": 3}
for key in data:
    if data[key] < 2:
        del data[key]  # RuntimeError: dictionary changed size during iteration
```

Instead, collect the keys to remove first, then delete them:

```python
data = {"a": 1, "b": 2, "c": 3}
keys_to_remove = [key for key, value in data.items() if value < 2]
for key in keys_to_remove:
    del data[key]
print(data)  # {'b': 2, 'c': 3}
```

## Summary

In this chapter, you learned:

- Dictionaries map keys to values and provide instant lookups: `contact["name"]`
- Use `.get(key, default)` for safe access when a key might not exist
- Add or update entries with `dict[key] = value`; remove with `del` or `.pop()`
- Iterate over keys, values, or key-value pairs with `.keys()`, `.values()`, `.items()`
- Sets store unique elements and support union (`|`), intersection (`&`), and difference (`-`)
- Choose the right data structure based on your access pattern and mutability needs

**Key syntax patterns:**

```python
# Create and access a dictionary
contact = {"name": "Alice", "email": "alice@example.com"}
name = contact["name"]
phone = contact.get("phone", "N/A")

# Iterate over key-value pairs
for key, value in contact.items():
    print(f"{key}: {value}")

# Create and use a set
skills = {"Python", "SQL", "JavaScript"}
other = {"Python", "Java"}
common = skills & other  # {'Python'}
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 2.2: Dictionaries and sets in practice**.

In this lab, you will:

- Build a contact book mapping names to phone numbers
- Count word frequencies in a text using dictionaries
- Use `.get()` to handle missing keys without errors
- Find common elements between two lists using sets
- Choose the right data structure for different scenarios

Open VS Code and proceed to Lab 2.2.
