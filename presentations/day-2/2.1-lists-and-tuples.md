# Chapter 2.1: Lists and tuples

**Reading time**: 25 minutes  
**Topics covered**: Lists, list methods, indexing, slicing, iteration, tuples, choosing between lists and tuples  
**Prerequisite reading**: Chapter 1.3  
**Associated lab**: Lab 2.1 - Working with lists and tuples

## What you will learn

After reading this chapter, you will be able to:

- Create lists and access elements by index
- Modify lists using methods like `append`, `insert`, `remove`, `pop`, and `sort`
- Extract sub-lists with slicing and test membership with `in`
- Iterate over lists with `for` loops and `enumerate()`
- Explain the difference between lists and tuples and choose the right one for a given task

## Introduction

So far, every piece of data you have stored used a separate variable: `name`, `age`, `city`. This works when you have a handful of values, but imagine tracking the grades of 30 students, a shopping cart with dozens of items, or daily temperature readings for a year. Creating `grade_1`, `grade_2`, ... `grade_30` is unmanageable.

Python solves this with **collections** — data structures that hold multiple values under a single name. The most common collection is the **list**: an ordered, changeable sequence of items. Lists let you store, access, modify, and iterate over groups of related data with clean, readable code.

This chapter introduces lists and their immutable counterpart, **tuples**. You will learn how to build, manipulate, and traverse ordered collections — skills you will use in virtually every Python program you write.

## 2.1.1 Creating lists

A **list** is an ordered collection of items enclosed in square brackets, separated by commas:

```python
fruits = ["apple", "banana", "cherry"]
temperatures = [22.5, 19.0, 25.3, 18.7]
scores = [85, 92, 78, 96, 88]
```

Lists can hold any data type, and items do not need to be the same type:

```python
mixed = ["Alice", 28, True, 3.14]
```

You can also create an empty list and fill it later:

```python
tasks = []
```

The built-in `len()` function returns the number of items in a list:

```python
fruits = ["apple", "banana", "cherry"]
print(len(fruits))
```

This produces:

```
3
```

**Think about it:**

Consider a scenario where you need to store a list of student names and later add a new student who enrolled late. With individual variables, you would need to create a new variable and update every piece of code that references the group. With a list, you call one method. Which approach scales better?

## 2.1.2 Accessing elements: Indexing

Each item in a list has a position called an **index**. Python uses zero-based indexing — the first item is at index 0, the second at index 1, and so on:

```python
fruits = ["apple", "banana", "cherry", "date"]
print(fruits[0])   # apple
print(fruits[1])   # banana
print(fruits[3])   # date
```

Python also supports **negative indexing**, which counts from the end of the list:

```python
print(fruits[-1])  # date   (last item)
print(fruits[-2])  # cherry (second to last)
```

Negative indexing is useful when you need the last few elements without knowing the exact length of the list.

If you try to access an index that does not exist, Python raises an `IndexError`:

```python
fruits = ["apple", "banana", "cherry"]
print(fruits[5])
```

```
IndexError: list index out of range
```

This is one of the most common errors beginners encounter. Always check your index against `len()` if you are unsure.

**Figure 2.1: List indexing**

```
Index:     0         1         2         3
        +----------+----------+----------+----------+
fruits: | "apple"  | "banana" | "cherry" | "date"   |
        +----------+----------+----------+----------+
         -4         -3         -2         -1
```

*Caption: Each element has both a positive index (left to right) and a negative index (right to left).*

## 2.1.3 Slicing: Extracting sub-lists

**Slicing** extracts a portion of a list using the syntax `list[start:stop]`. The slice includes the item at `start` but excludes the item at `stop`:

```python
numbers = [10, 20, 30, 40, 50, 60, 70]

print(numbers[1:4])    # [20, 30, 40]
print(numbers[:3])     # [10, 20, 30]      (from beginning)
print(numbers[4:])     # [50, 60, 70]      (to end)
print(numbers[-3:])    # [50, 60, 70]      (last three)
```

You can also specify a **step** as a third value:

```python
print(numbers[::2])    # [10, 30, 50, 70]  (every second item)
print(numbers[::-1])   # [70, 60, 50, 40, 30, 20, 10]  (reversed)
```

Slicing never raises an `IndexError`, even if the indices are out of range. Python simply returns as many items as exist within the specified range. This makes slicing forgiving compared to direct indexing.

The slicing syntax is the same one you learned for strings in Chapter 1.3. Lists and strings are both sequences, and sequences share these operations.

## 2.1.4 Modifying lists

Lists are **mutable** — you can change their contents after creation. This is one of the key differences between lists and strings (strings are immutable).

**Changing an element by index:**

```python
fruits = ["apple", "banana", "cherry"]
fruits[1] = "blueberry"
print(fruits)  # ["apple", "blueberry", "cherry"]
```

**Adding elements:**

```python
fruits = ["apple", "banana"]

fruits.append("cherry")       # Add to end
print(fruits)                 # ["apple", "banana", "cherry"]

fruits.insert(1, "avocado")   # Insert at index 1
print(fruits)                 # ["apple", "avocado", "banana", "cherry"]
```

**Removing elements:**

```python
fruits = ["apple", "banana", "cherry", "banana"]

fruits.remove("banana")       # Remove first occurrence
print(fruits)                 # ["apple", "cherry", "banana"]

last = fruits.pop()           # Remove and return last item
print(last)                   # banana
print(fruits)                 # ["apple", "cherry"]

fruits.pop(0)                 # Remove and return item at index 0
print(fruits)                 # ["cherry"]
```

The difference between `remove()` and `pop()` matters: `remove()` searches by value and removes the first match. `pop()` removes by index and returns the removed item. If you need the removed value, use `pop()`. If you know the value but not the index, use `remove()`.

**Warning:**

Calling `remove()` with a value that does not exist raises a `ValueError`. Always check membership first with `in`, or handle the exception with `try`/`except` (covered in Chapter 3.4).

## 2.1.5 List methods and operations

Python lists come with a rich set of methods for common tasks.

**Sorting:**

```python
numbers = [42, 17, 8, 93, 55]
numbers.sort()
print(numbers)  # [8, 17, 42, 55, 93]

numbers.sort(reverse=True)
print(numbers)  # [93, 55, 42, 17, 8]
```

The `sort()` method modifies the list in place. If you need a new sorted list without changing the original, use the built-in `sorted()` function:

```python
original = [42, 17, 8, 93, 55]
ordered = sorted(original)
print(original)  # [42, 17, 8, 93, 55]  (unchanged)
print(ordered)   # [8, 17, 42, 55, 93]
```

**Reversing:**

```python
items = [1, 2, 3, 4, 5]
items.reverse()
print(items)  # [5, 4, 3, 2, 1]
```

**Membership testing with `in`:**

```python
fruits = ["apple", "banana", "cherry"]
print("banana" in fruits)      # True
print("grape" in fruits)       # False
print("grape" not in fruits)   # True
```

The `in` operator checks whether a value exists in the list. This is readable, concise, and the Pythonic way to test membership.

**Counting and finding:**

```python
numbers = [3, 7, 3, 9, 3, 1]
print(numbers.count(3))    # 3  (appears three times)
print(numbers.index(9))    # 3  (first occurrence at index 3)
```

**Concatenation and repetition:**

```python
a = [1, 2, 3]
b = [4, 5, 6]
combined = a + b
print(combined)     # [1, 2, 3, 4, 5, 6]

repeated = [0] * 5
print(repeated)     # [0, 0, 0, 0, 0]
```

**In practice:**

List methods cover the majority of operations you will need. When you build an application that manages a to-do list, a product inventory, or a set of log entries, you will use `append()` to add items, `remove()` or `pop()` to delete them, `sort()` to organize them, and `in` to search them.

## 2.1.6 Iterating over lists

Processing every item in a list is one of the most common programming tasks. Python's `for` loop makes this straightforward:

```python
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)
```

```
apple
banana
cherry
```

The variable `fruit` takes on each value in the list, one at a time. The indented block runs once for each item. You will learn more about `for` loops in Chapter 2.4, but the pattern `for item in collection` is essential to understand now.

**Using `enumerate()` for index and value:**

Often you need both the position and the value during iteration. The `enumerate()` function provides both:

```python
fruits = ["apple", "banana", "cherry"]
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")
```

```
0: apple
1: banana
2: cherry
```

You can also start the index from a different number:

```python
for position, fruit in enumerate(fruits, start=1):
    print(f"{position}. {fruit}")
```

```
1. apple
2. banana
3. cherry
```

This is useful when you want to display numbered lists to users, since humans count from 1, not 0.

## 2.1.7 Tuples: Immutable sequences

A **tuple** is an ordered collection that cannot be changed after creation. You create tuples with parentheses instead of square brackets:

```python
coordinates = (10.5, 20.3)
rgb_color = (255, 128, 0)
person = ("Alice", 28, "Budapest")
```

Tuples support indexing, slicing, `len()`, `in`, and iteration — just like lists. The critical difference is that you cannot modify a tuple after creation:

```python
coordinates = (10.5, 20.3)
print(coordinates[0])      # 10.5
print(len(coordinates))    # 2

coordinates[0] = 99.9      # TypeError: 'tuple' object does not support item assignment
```

**Why use tuples when lists are more flexible?**

Tuples serve a specific purpose: they represent fixed collections of data that should not change. Consider these examples:

- Geographic coordinates: `(47.497, 19.040)` — latitude and longitude should not be modified independently
- RGB color values: `(255, 128, 0)` — a color is a fixed combination
- Database records: `("Alice", "alice@example.com", 28)` — a row of data read from a database

Using a tuple signals intent: "this data is fixed." This makes your code clearer and prevents accidental modification.

**Tuple unpacking:**

Python lets you assign tuple elements to separate variables in a single line:

```python
person = ("Alice", 28, "Budapest")
name, age, city = person
print(name)   # Alice
print(age)    # 28
print(city)   # Budapest
```

This works with any iterable, but it is most commonly used with tuples. The number of variables on the left must match the number of items in the tuple.

**Note:**

To create a tuple with a single element, you must include a trailing comma: `single = (42,)`. Without the comma, `(42)` is just the integer 42 in parentheses, not a tuple. This is a common source of confusion.

## 2.1.8 Choosing between lists and tuples

The choice between lists and tuples comes down to two questions:

1. **Will the data change?** If yes, use a list. If no, use a tuple.
2. **What does the data represent?** If it is a collection of similar items (names, scores, products), use a list. If it is a fixed record of different fields (name + age + city), use a tuple.

| Feature | List | Tuple |
|---------|------|-------|
| Syntax | `[1, 2, 3]` | `(1, 2, 3)` |
| Mutable | Yes | No |
| Use case | Collection of similar items | Fixed record of related fields |
| Methods | Many (`append`, `sort`, etc.) | Few (`count`, `index`) |
| Performance | Slightly slower | Slightly faster |

In practice, lists are far more common than tuples in everyday code. Use tuples when immutability matters or when returning multiple values from a function (covered in Chapter 3.1).

## 2.1.9 Common pitfalls

**Off-by-one errors with indexing**

Because Python uses zero-based indexing, the last element of a list with 5 items is at index 4, not 5. Accessing index 5 raises an `IndexError`:

```python
items = ["a", "b", "c", "d", "e"]
print(items[5])  # IndexError: list index out of range
print(items[4])  # "e" (correct)
```

**Modifying a list while iterating over it**

Removing items from a list during a `for` loop can skip elements or cause unexpected results:

```python
# This is WRONG — elements get skipped
numbers = [1, 2, 3, 4, 5]
for n in numbers:
    if n % 2 == 0:
        numbers.remove(n)
print(numbers)  # [1, 3, 5]? Not guaranteed to be correct.
```

Instead, build a new list with the items you want to keep:

```python
# This is correct
numbers = [1, 2, 3, 4, 5]
odd_numbers = [n for n in numbers if n % 2 != 0]
print(odd_numbers)  # [1, 3, 5]
```

You will learn more about this `[... for ... in ...]` syntax (list comprehensions) in Chapter 4.1.

**Confusing `sort()` and `sorted()`**

`sort()` modifies the list in place and returns `None`. `sorted()` returns a new sorted list. A common mistake:

```python
numbers = [3, 1, 2]
result = numbers.sort()
print(result)   # None (sort() returns nothing)
print(numbers)  # [1, 2, 3] (modified in place)
```

If you need the sorted result as a value, use `sorted()`:

```python
numbers = [3, 1, 2]
result = sorted(numbers)
print(result)   # [1, 2, 3]
```

## Summary

In this chapter, you learned:

- Lists are ordered, mutable collections created with square brackets `[]`
- Items are accessed by zero-based index: `my_list[0]` is the first element
- Slicing extracts sub-lists: `my_list[1:4]` returns items at indices 1, 2, and 3
- Lists provide methods for adding (`append`, `insert`), removing (`remove`, `pop`), and sorting (`sort`, `sorted`)
- The `in` operator tests membership: `"apple" in fruits` returns True or False
- Tuples are immutable ordered collections created with parentheses `()`
- Use lists for changeable collections of similar items; use tuples for fixed records

**Key syntax patterns:**

```python
# Create and modify a list
items = ["a", "b", "c"]
items.append("d")
items[0] = "A"

# Iterate with enumerate
for index, item in enumerate(items):
    print(f"{index}: {item}")

# Create a tuple
record = ("Alice", 28, "Budapest")
name, age, city = record

# Membership test
if "b" in items:
    print("Found")
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 2.1: Working with lists and tuples**.

In this lab, you will:

- Build a to-do list in the REPL using list methods
- Add, remove, and sort items interactively
- Use slicing to extract portions of a list
- Store fixed records as tuples and unpack them
- Display numbered lists using `enumerate()`

Open VS Code and proceed to Lab 2.1.
