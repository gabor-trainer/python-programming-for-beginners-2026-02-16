# Chapter 3.4: Error and exception handling

**Reading time**: 25 minutes  
**Topics covered**: `try` / `except` / `else` / `finally`, catching specific exceptions, raising exceptions, reading tracebacks  
**Prerequisite reading**: Chapter 3.3  
**Associated lab**: Lab 3.4 - Handling errors gracefully

## What you will learn

After reading this chapter, you will be able to:

- Use `try` / `except` to handle runtime errors without crashing
- Catch specific exception types and handle each appropriately
- Use `else` and `finally` blocks to control post-exception flow
- Raise exceptions in your own functions using `raise`
- Read and interpret Python tracebacks to locate the source of errors
- Apply defensive programming principles to write robust code

## Introduction

Every program encounters errors. A file might not exist. A user might type "abc" when you expected a number. A network connection might drop. If your code does not handle these situations, Python terminates immediately and prints a traceback — a wall of text that is intimidating at first but extremely useful once you know how to read it.

Up to now, a single error crashed your entire script. This chapter introduces **exception handling**, the mechanism Python provides for dealing with errors at runtime. Instead of crashing, your code can detect the problem, respond appropriately, and continue running. You will also learn to **raise** your own exceptions when your functions receive invalid input, and — critically — to **read tracebacks** so you can quickly find and fix bugs.

Defensive programming is not about preventing all errors. It is about anticipating what can go wrong and deciding what should happen when it does.

## 3.4.1 What are exceptions?

When Python encounters an error during execution, it creates an **exception object** and stops running the current code. You have already seen several exceptions in this course:

```
>>> int("abc")
ValueError: invalid literal for int() with base 10: 'abc'

>>> numbers = [1, 2, 3]
>>> numbers[10]
IndexError: list index out of range

>>> open("missing.txt")
FileNotFoundError: [Errno 2] No such file or directory: 'missing.txt'
```

Each exception has a **type** (like `ValueError`, `IndexError`, `FileNotFoundError`) and a **message** that describes what went wrong. The type tells you the *category* of the error; the message tells you the *specifics*.

Common exception types you will encounter:

| Exception | When it occurs |
|-----------|----------------|
| `ValueError` | Wrong value (e.g., converting "abc" to int) |
| `TypeError` | Wrong type (e.g., adding string and integer) |
| `IndexError` | List index out of range |
| `KeyError` | Dictionary key not found |
| `FileNotFoundError` | File or directory does not exist |
| `ZeroDivisionError` | Division by zero |
| `AttributeError` | Object has no such attribute or method |
| `NameError` | Variable or function name not defined |
| `ImportError` | Module or name cannot be imported |

## 3.4.2 The try/except block

The `try`/`except` block lets you attempt an operation and handle the error if it fails:

```python
try:
    age = int(input("Enter your age: "))
    print(f"You are {age} years old.")
except ValueError:
    print("That is not a valid number.")
```

Python executes the code inside `try`. If no error occurs, the `except` block is skipped entirely. If a `ValueError` occurs, Python jumps to the `except` block and executes that code instead of crashing.

Here is a practical example — reading a file safely:

```python
try:
    with open("config.txt") as f:
        config = f.read()
    print(f"Config loaded: {len(config)} characters")
except FileNotFoundError:
    print("Config file not found. Using defaults.")
    config = "default_setting=true"
```

**Warning:**

Always catch **specific** exception types. A bare `except:` (without a type) catches every possible error, including keyboard interrupts and system exits. This hides bugs and makes debugging much harder:

```python
# Bad - catches everything, hides real bugs
try:
    result = calculate(data)
except:
    print("Something went wrong")

# Good - catches only what you expect
try:
    result = calculate(data)
except ValueError:
    print("Invalid data format")
```

## 3.4.3 Catching multiple exceptions

You can handle different exception types with separate `except` blocks:

```python
def read_score(filename, index):
    """Read a specific score from a file of numbers."""
    try:
        with open(filename) as f:
            lines = f.readlines()
        score = int(lines[index].strip())
        return score
    except FileNotFoundError:
        print(f"File '{filename}' not found.")
        return None
    except IndexError:
        print(f"Line {index} does not exist in the file.")
        return None
    except ValueError:
        print(f"Line {index} does not contain a valid number.")
        return None

result = read_score("scores.txt", 0)
if result is not None:
    print(f"Score: {result}")
```

Each `except` block handles one type of failure. This gives you precise control over the response to each error.

You can also catch multiple exceptions in a single block if the response is the same:

```python
try:
    value = int(user_input)
    result = 100 / value
except (ValueError, ZeroDivisionError):
    print("Please enter a valid non-zero number.")
```

## 3.4.4 The else and finally blocks

The full `try` statement has four parts:

```python
try:
    f = open("data.txt")
    content = f.read()
except FileNotFoundError:
    print("File not found.")
    content = ""
else:
    print(f"Successfully read {len(content)} characters.")
finally:
    print("Cleanup complete.")
```

- **`try`**: Code that might raise an exception
- **`except`**: Runs only if an exception occurs
- **`else`**: Runs only if *no* exception occurred — use this for code that should run only on success
- **`finally`**: Runs *always*, whether an exception occurred or not — use this for cleanup (closing connections, releasing resources)

The `else` block is valuable because it keeps the "success path" separate from the `try` block. Code in `else` is not protected by the `except`, so if it raises an error, that error is not accidentally caught.

```python
def safe_divide(a, b):
    """Divide a by b, handling division by zero."""
    try:
        result = a / b
    except ZeroDivisionError:
        print("Cannot divide by zero.")
        return None
    else:
        print(f"{a} / {b} = {result:.2f}")
        return result
    finally:
        print("Division operation attempted.")
```

**Think about it:**

Why put code in `else` rather than at the end of the `try` block? Consider: if you put extra code in `try`, an unexpected error in that extra code would be caught by the `except` — potentially hiding a bug. The `else` block only runs when the `try` succeeds but is *not* protected by the `except`.

## 3.4.5 Raising exceptions

Your own functions should raise exceptions when they receive invalid input. This tells the calling code that something is wrong, rather than silently returning a bad result:

```python
def calculate_discount(price, percentage):
    """Calculate a discount. Percentage must be between 0 and 100."""
    if not isinstance(price, (int, float)):
        raise TypeError(f"Price must be a number, got {type(price).__name__}")
    if not isinstance(percentage, (int, float)):
        raise TypeError(f"Percentage must be a number, got {type(percentage).__name__}")
    if percentage < 0 or percentage > 100:
        raise ValueError(f"Percentage must be 0-100, got {percentage}")
    if price < 0:
        raise ValueError(f"Price cannot be negative, got {price}")

    return price * (percentage / 100)
```

The calling code can then decide how to handle the error:

```python
try:
    discount = calculate_discount(99.99, 110)
except ValueError as e:
    print(f"Invalid input: {e}")
```

Output:

```
Invalid input: Percentage must be 0-100, got 110
```

The `as e` syntax captures the exception object, giving you access to its message. This is useful for logging or displaying the error to the user.

**In practice:**

In professional code, functions validate their inputs and raise clear exceptions with descriptive messages. This creates a contract: the function documents what it expects, and raises an informative error if the caller breaks that contract. The caller decides how to handle the error — display a message, retry, use a default, or let it propagate up.

## 3.4.6 Reading tracebacks

A **traceback** is Python's error report. Learning to read it quickly is one of the most important debugging skills. Consider this code:

```python
# scores.py

def calculate_average(scores):
    total = sum(scores)
    return total / len(scores)


def process_scores(filename):
    with open(filename) as f:
        lines = f.readlines()
    scores = [int(line.strip()) for line in lines]
    average = calculate_average(scores)
    return average


result = process_scores("scores.txt")
print(f"Average: {result}")
```

If `scores.txt` is empty, you get this traceback:

```
Traceback (most recent call last):
  File "C:\labs\scores.py", line 15, in <module>
    result = process_scores("scores.txt")
  File "C:\labs\scores.py", line 12, in process_scores
    average = calculate_average(scores)
  File "C:\labs\scores.py", line 4, in calculate_average
    return total / len(scores)
ZeroDivisionError: division by zero
```

**How to read a traceback — three steps:**

1. **Start at the bottom.** The last line tells you the exception type and message: `ZeroDivisionError: division by zero`. This is *what* went wrong.

2. **Look at the line above it.** The last entry in the traceback shows *where* the error occurred: line 4, `return total / len(scores)`. The `len(scores)` returned `0` because the list was empty.

3. **Read upward to follow the call chain.** Line 12 called `calculate_average(scores)`, and line 15 called `process_scores("scores.txt")`. This shows *how* you got there.

The traceback reads from **oldest call to newest** (top to bottom). The actual error is always at the **bottom**.

**Tip:**

When you encounter a traceback, resist the urge to re-read your entire script. The traceback tells you exactly where to look. Read the last line for the error type, then the line above for the exact location, and you have your starting point for debugging.

## 3.4.7 Practical pattern: input validation loop

A common pattern combines exception handling with a loop to keep asking until the user provides valid input:

```python
def get_positive_number(prompt):
    """Keep asking until the user enters a positive number."""
    while True:
        try:
            value = float(input(prompt))
        except ValueError:
            print("Please enter a valid number.")
            continue

        if value <= 0:
            print("The number must be positive.")
            continue

        return value

price = get_positive_number("Enter the price: ")
quantity = get_positive_number("Enter the quantity: ")
print(f"Total: ${price * quantity:,.2f}")
```

This pattern is robust: it handles non-numeric input (via `except ValueError`) and invalid values (via the `if` check), and it only exits the loop when valid input is received.

## 3.4.8 Practical pattern: logging errors to a file

Instead of displaying errors on screen (where they may go unnoticed), you can log them:

```python
from datetime import datetime


def log_error(error_message, log_file="errors.log"):
    """Append an error message with a timestamp to the log file."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(log_file, "a") as f:
        f.write(f"[{timestamp}] {error_message}\n")


def process_data_file(filename):
    """Process a data file, logging any errors."""
    try:
        with open(filename) as f:
            lines = f.readlines()
    except FileNotFoundError:
        log_error(f"File not found: {filename}")
        return []

    results = []
    for i, line in enumerate(lines, start=1):
        try:
            value = float(line.strip())
            results.append(value)
        except ValueError:
            log_error(f"Invalid number on line {i} of {filename}: {line.strip()!r}")

    return results
```

This script processes what it can and logs what it cannot, instead of crashing on the first bad line.

## 3.4.9 Common pitfalls

**Catching too broadly**

```python
# Bad - hides all errors, including bugs in your code
try:
    result = process(data)
except Exception:
    pass   # Silently ignores EVERY error
```

Only catch exceptions you can actually handle. If you do not know what to do with an error, let it propagate — it is better to see the traceback and fix the bug than to silently ignore it.

**Putting too much code in `try`**

```python
# Bad - hard to tell which line caused the error
try:
    filename = input("Enter filename: ")
    f = open(filename)
    data = f.read()
    f.close()
    numbers = [int(x) for x in data.split()]
    average = sum(numbers) / len(numbers)
    print(f"Average: {average}")
except Exception as e:
    print(f"Error: {e}")
```

Keep `try` blocks short and focused. Wrap only the operation that might fail, not your entire program.

**Using exceptions for normal flow control**

```python
# Bad - using exceptions to check if a key exists
try:
    value = my_dict[key]
except KeyError:
    value = "default"

# Good - use the built-in method designed for this
value = my_dict.get(key, "default")
```

Exceptions should handle *exceptional* situations, not replace simple conditional checks.

## Summary

In this chapter, you learned:

- `try`/`except` catches runtime errors and lets your code recover instead of crashing
- Always catch **specific** exception types, not bare `except` or `except Exception`
- `else` runs only when no exception occurred; `finally` runs always (cleanup)
- Use `raise` to signal errors from your own functions with descriptive messages
- Read tracebacks **from the bottom up**: exception type first, then location, then call chain
- The input validation loop pattern (`while True` + `try`/`except` + `continue`/`return`) handles user input robustly
- Keep `try` blocks short and focused on the operation that might fail

**Key syntax pattern:**

```python
# Handle specific errors
try:
    value = int(user_input)
except ValueError as e:
    print(f"Invalid input: {e}")
else:
    print(f"Success: {value}")
finally:
    print("Done.")

# Raise your own exceptions
def validate_age(age):
    if age < 0 or age > 150:
        raise ValueError(f"Invalid age: {age}")
    return age

# Read tracebacks: start at the bottom line
# ZeroDivisionError: division by zero  ← WHAT went wrong
#   File "script.py", line 4            ← WHERE it happened
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 3.4: Handling errors gracefully**.

In this lab, you will:

- Add error handling to file-reading code (`FileNotFoundError`)
- Validate user input with `try`/`except` (`ValueError`)
- Create a function that raises exceptions for invalid arguments
- Read and interpret tracebacks to find and fix bugs
- Build a script that logs errors to a file instead of crashing

Open your editor and proceed to Lab 3.4.
