# Chapter 3.2: Reading and writing files

**Reading time**: 25 minutes  
**Topics covered**: `open()`, read modes, reading methods, writing files, the `with` statement, CSV files  
**Prerequisite reading**: Chapter 3.1  
**Associated lab**: Lab 3.2 - File operations

## What you will learn

After reading this chapter, you will be able to:

- Open files for reading, writing, and appending using `open()`
- Read file contents with `read()`, `readline()`, and `readlines()`
- Write text and data to files safely
- Use the `with` statement to ensure files are properly closed
- Read and write simple CSV files

## Introduction

Every script you have written so far loses its data when the program ends. Variables exist in memory and vanish when Python exits. To store results permanently, send reports to colleagues, or process data from external sources, you need **file I/O** (input/output).

File operations are among the most practical skills in programming. A system administrator reads log files to find errors. A data analyst loads CSV exports from a database. A web developer writes configuration files. An automation script reads a list of tasks from a text file and writes a status report when done.

This chapter teaches you to read from files, write to files, and — critically — do so safely. Python's `with` statement ensures files are properly closed even when errors occur, preventing data corruption and resource leaks. You will also learn to work with CSV files, one of the most common formats for structured data exchange.

## 3.2.1 Opening and reading a file

The built-in `open()` function creates a **file object** that you use to read or write data. The simplest way to read a file is with the `read()` method:

```python
file = open("notes.txt", "r")
content = file.read()
print(content)
file.close()
```

Let us break this down:

- `open("notes.txt", "r")` opens the file `notes.txt` in **read mode** (`"r"`). The file must exist; otherwise, Python raises a `FileNotFoundError`.
- `file.read()` reads the entire file content into a single string.
- `file.close()` releases the file. This step is critical — forgetting it can lead to data corruption or resource leaks.

The second argument to `open()` is the **mode**:

| Mode | Meaning | Behaviour |
|------|---------|-----------|
| `"r"` | Read | Opens for reading (default). File must exist. |
| `"w"` | Write | Opens for writing. Creates the file if it does not exist. **Overwrites** if it does. |
| `"a"` | Append | Opens for writing at the end. Creates the file if it does not exist. Preserves existing content. |
| `"r+"` | Read+Write | Opens for both reading and writing. File must exist. |

**Warning:**

Mode `"w"` erases the entire file before writing. If you open an important file with `"w"` by accident, its contents are gone immediately. Use `"a"` to add to an existing file without destroying its contents.

## 3.2.2 The `with` statement

Manually calling `file.close()` is risky. If an error occurs between `open()` and `close()`, the file never gets closed. Python's `with` statement solves this:

```python
with open("notes.txt", "r") as file:
    content = file.read()
    print(content)
```

The `with` statement guarantees that the file is closed when the block ends — whether the code completes normally or an error occurs. This is the standard way to work with files in Python. Every file operation in this course uses `with`.

The variable name after `as` (here, `file`) is the file object. You can name it anything: `f`, `file`, `input_file`, etc. Descriptive names are preferred.

**Tip:**

Always use `with open(...) as file:` for file operations. Treat it as a rule, not a suggestion. Forgetting to close a file might not cause visible problems in small scripts, but it leads to real issues in long-running programs and when writing data.

## 3.2.3 Reading methods

Python offers several ways to read file content, each suited to different situations.

**`read()`** — read the entire file as one string:

```python
with open("notes.txt", "r") as file:
    content = file.read()
    print(content)
```

This is convenient for small files. For very large files (hundreds of megabytes), loading everything into memory at once may not be practical.

**`readline()`** — read one line at a time:

```python
with open("notes.txt", "r") as file:
    first_line = file.readline()
    second_line = file.readline()
    print(f"First:  {first_line.strip()}")
    print(f"Second: {second_line.strip()}")
```

Each call to `readline()` reads the next line, including the newline character `\n` at the end. Use `.strip()` to remove it.

**`readlines()`** — read all lines into a list:

```python
with open("notes.txt", "r") as file:
    lines = file.readlines()
    print(f"Total lines: {len(lines)}")
    for line in lines:
        print(line.strip())
```

Each element in the list is one line (with `\n` at the end).

**Iterating directly** — the most Pythonic approach for processing line by line:

```python
with open("notes.txt", "r") as file:
    for line in file:
        print(line.strip())
```

This reads one line at a time without loading the entire file into memory, making it efficient for files of any size. This is the recommended approach for most line-by-line processing.

**Think about it:**

You need to process a 5 GB log file. Which reading method would you use — `read()`, `readlines()`, or iterating directly with `for line in file:`? Why?

## 3.2.4 Writing to files

To write data, open a file in write mode (`"w"`) or append mode (`"a"`):

```python
# Write mode — creates or overwrites the file
with open("output.txt", "w") as file:
    file.write("Line one\n")
    file.write("Line two\n")
    file.write("Line three\n")
```

The `write()` method does not add a newline automatically — you must include `\n` yourself.

After running this code, `output.txt` contains:

```
Line one
Line two
Line three
```

**Appending to a file:**

```python
# Append mode — adds to the end of the file
with open("log.txt", "a") as file:
    file.write("2025-01-15 10:30: User logged in\n")
    file.write("2025-01-15 10:35: File uploaded\n")
```

Each time you run this script, the new entries are added after the existing content. This is how log files work — they grow over time.

**Writing multiple lines at once:**

```python
lines = ["Apple\n", "Banana\n", "Cherry\n"]

with open("fruits.txt", "w") as file:
    file.writelines(lines)
```

`writelines()` writes each string from the list. Like `write()`, it does not add newlines automatically — each string must include `\n` if you want separate lines.

A practical example — reading a file, processing it, and writing results:

```python
with open("names.txt", "r") as infile:
    names = [line.strip() for line in infile]

# Sort and write to a new file
names.sort()

with open("names_sorted.txt", "w") as outfile:
    for name in names:
        outfile.write(f"{name}\n")

print(f"Sorted {len(names)} names.")
```

## 3.2.5 Working with file paths on Windows

Python handles Windows file paths with backslashes, but backslashes are also escape characters in strings (`\n` means newline, `\t` means tab). You have three options:

**Raw strings** (recommended):

```python
with open(r"C:\labs\data\report.txt", "r") as file:
    content = file.read()
```

The `r` prefix before the string tells Python to treat backslashes literally.

**Forward slashes** (also works on Windows):

```python
with open("C:/labs/data/report.txt", "r") as file:
    content = file.read()
```

Python accepts forward slashes on all platforms.

**`pathlib.Path`** (cleanest for complex paths):

```python
from pathlib import Path

data_dir = Path("C:/labs/data")
file_path = data_dir / "report.txt"

with open(file_path, "r") as file:
    content = file.read()
```

You will learn more about `pathlib` in Chapter 3.3.

**Tip:**

When building file paths that combine directory and file names, use `pathlib.Path` with the `/` operator. It handles path separators correctly on any operating system and avoids the backslash escape problem entirely.

## 3.2.6 Reading and writing CSV files

**CSV** (Comma-Separated Values) is a common format for tabular data — spreadsheets, database exports, data analysis inputs. Each line is a row, and values within a row are separated by commas:

```
name,age,city
Alice,30,Budapest
Bob,25,Prague
Charlie,28,Vienna
```

Python's built-in `csv` module handles CSV reading and writing:

```python
import csv

# Reading a CSV file
with open("people.csv", "r") as file:
    reader = csv.reader(file)
    header = next(reader)  # Read the header row
    print(f"Columns: {header}")

    for row in reader:
        name, age, city = row
        print(f"  {name} is {age}, lives in {city}")
```

`csv.reader` yields each row as a list of strings. The `next()` call reads the first row (the header) separately.

**Writing CSV files:**

```python
import csv

employees = [
    ["Alice", "Engineering", 75000],
    ["Bob", "Marketing", 62000],
    ["Charlie", "Engineering", 80000],
]

with open("employees.csv", "w", newline="") as file:
    writer = csv.writer(file)
    writer.writerow(["Name", "Department", "Salary"])  # Header
    writer.writerows(employees)  # All data rows
```

The `newline=""` parameter in `open()` prevents extra blank lines on Windows — always include it when writing CSV.

**Using `DictReader` for named access:**

```python
import csv

with open("people.csv", "r") as file:
    reader = csv.DictReader(file)
    for row in reader:
        print(f"  {row['name']} lives in {row['city']}")
```

`DictReader` uses the header row as keys, so you access fields by name instead of index. This is more readable and less error-prone.

**In practice:**

CSV is the lingua franca of data exchange. When you export data from Excel, a database, or a web application, CSV is usually an option. Python's `csv` module handles edge cases like quoted fields (values containing commas) and different delimiters (semicolons are common in Europe). For complex data analysis, the `pandas` library (Day 4 mention) provides even more powerful CSV handling.

## 3.2.7 Common pitfalls

**Forgetting `newline=""` when writing CSV on Windows**

Without `newline=""` in the `open()` call, CSV files on Windows get double-spaced with empty lines between rows:

```python
# WRONG on Windows — extra blank lines
with open("data.csv", "w") as file:
    writer = csv.writer(file)
    writer.writerows(data)

# CORRECT
with open("data.csv", "w", newline="") as file:
    writer = csv.writer(file)
    writer.writerows(data)
```

**Opening a file with `"w"` when you meant `"a"`**

Mode `"w"` erases everything before writing. If you run a script that writes daily reports to the same file using `"w"`, you only keep the last report. Use `"a"` to accumulate entries.

**Reading a file that does not exist**

```python
# Raises FileNotFoundError
with open("nonexistent.txt", "r") as file:
    content = file.read()
```

You will learn to handle this gracefully with `try`/`except` in Chapter 3.4.

**Forgetting `.strip()` when processing lines**

Lines read from a file include the trailing newline character `\n`. If you compare them directly, comparisons fail:

```python
# "Alice\n" != "Alice"
for line in file:
    if line == "Alice":      # Never matches
        print("Found!")

    if line.strip() == "Alice":  # Works correctly
        print("Found!")
```

## Summary

In this chapter, you learned:

- `open(filename, mode)` opens a file for reading (`"r"`), writing (`"w"`), or appending (`"a"`)
- `with open(...) as file:` guarantees the file is closed properly — always use this form
- `read()` loads the entire file; `readline()` reads one line; iterating with `for line in file:` is most efficient
- `write()` and `writelines()` write data; they do not add newlines automatically
- Use raw strings (`r"C:\path"`) or forward slashes for Windows file paths
- The `csv` module reads and writes CSV files; `DictReader` provides named field access
- Always include `newline=""` when writing CSV on Windows

**Key syntax pattern:**

```python
# Reading a text file
with open("data.txt", "r") as file:
    for line in file:
        print(line.strip())

# Writing a text file
with open("output.txt", "w") as file:
    file.write("content\n")

# Reading CSV
import csv
with open("data.csv", "r") as file:
    reader = csv.DictReader(file)
    for row in reader:
        print(row["column_name"])
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 3.2: File operations**.

In this lab, you will:

- Read a text file and count lines, words, and characters
- Write processed results to a new file
- Append log entries to a growing log file
- Read and write CSV data using the `csv` module

Open your editor and proceed to Lab 3.2.
