# Chapter 3.1: Defining and calling functions

**Reading time**: 25 minutes  
**Topics covered**: Function definition, parameters, arguments, return values, default and keyword arguments, variable scope  
**Prerequisite reading**: Chapter 2.4  
**Associated lab**: Lab 3.1 - Writing reusable functions

## What you will learn

After reading this chapter, you will be able to:

- Define functions with `def` and call them with arguments
- Use parameters, return values, default parameters, and keyword arguments
- Explain the difference between local and global scope
- Apply the DRY principle by extracting repeated code into reusable functions
- Recognize when and why to create a function

## Introduction

By now you have written scripts that perform useful work: converting temperatures, validating input, processing lists. But look at any non-trivial script and you will find repeated patterns. The same validation logic appears in three places. The same formatting code is copied across two functions. When you fix a bug in one copy, you forget to fix the other.

**Functions** solve this problem. A function is a named block of code that you define once and call whenever you need it. Instead of copying five lines of temperature conversion logic everywhere, you write a `celsius_to_fahrenheit()` function and call it with a single line. The code lives in one place, is tested once, and is reused everywhere.

This chapter teaches you to define your own functions, pass data in through parameters, get results back with `return`, and understand how Python manages variable names inside and outside functions. Functions are the single most important tool for writing maintainable code.

## 3.1.1 Your first function

A function definition starts with the `def` keyword, followed by a name, parentheses, and a colon. The indented block below is the function body:

```python
def greet():
    print("Hello! Welcome to the program.")
```

This defines a function called `greet`. It does not run the code inside — it only stores it under that name. To execute the function, you **call** it:

```python
greet()
```

This produces:

```
Hello! Welcome to the program.
```

You can call a function as many times as you need:

```python
greet()
greet()
greet()
```

Each call executes the entire function body from the beginning.

**Key terms:**

- **Function definition**: The `def` block that creates the function
- **Function call**: Using the function name with parentheses to execute it
- **Function body**: The indented code inside the definition

**Tip:**

Function names follow the same rules as variable names: lowercase, with underscores separating words (snake_case). Choose names that describe what the function does: `calculate_tax`, `validate_email`, `format_name`.

## 3.1.2 Parameters and arguments

Most functions need data to work with. You provide this data through **parameters** — variable names listed in the function definition — and **arguments** — actual values you pass when calling the function:

```python
def greet(name):
    print(f"Hello, {name}!")


greet("Alice")
greet("Bob")
```

This produces:

```
Hello, Alice!
Hello, Bob!
```

Here, `name` is a **parameter** (in the definition) and `"Alice"` is an **argument** (in the call). When Python executes `greet("Alice")`, it assigns `"Alice"` to `name` and runs the body.

Functions can accept multiple parameters:

```python
def describe_pet(name, animal_type):
    print(f"{name} is a {animal_type}.")


describe_pet("Max", "dog")
describe_pet("Whiskers", "cat")
```

This produces:

```
Max is a dog.
Whiskers is a cat.
```

The order of arguments must match the order of parameters. If you swap them, you get incorrect results — `describe_pet("dog", "Max")` would print "dog is a Max."

**Note:**

The distinction between *parameter* and *argument* is precise: parameters are the names in the `def` line; arguments are the values in the call. In casual conversation, many programmers use the terms interchangeably, but understanding the difference helps when reading documentation.

## 3.1.3 Return values

Functions that only print results are limited — you cannot store or further process the output. The `return` statement sends a value back to the caller:

```python
def celsius_to_fahrenheit(celsius):
    fahrenheit = (celsius * 9 / 5) + 32
    return fahrenheit


result = celsius_to_fahrenheit(25)
print(f"25°C = {result}°F")
```

This produces:

```
25°C = 77.0°F
```

The call `celsius_to_fahrenheit(25)` evaluates to `77.0`, which is stored in `result`. You can use the returned value in any expression:

```python
# Use the return value directly in an f-string
print(f"Boiling point: {celsius_to_fahrenheit(100)}°F")

# Use it in a condition
if celsius_to_fahrenheit(temperature) > 100:
    print("Very hot!")
```

A function can return any type: a number, a string, a list, a dictionary, or even another function. You can also return multiple values as a tuple:

```python
def min_max(numbers):
    return min(numbers), max(numbers)


lowest, highest = min_max([4, 7, 1, 9, 3])
print(f"Range: {lowest} to {highest}")
```

This produces:

```
Range: 1 to 9
```

**Warning:**

A function without an explicit `return` statement returns `None`. If you write `result = my_function()` and the function has no `return`, `result` will be `None`. This is a common source of confusion when a function prints output but you expected it to return a value.

## 3.1.4 Default parameters

Sometimes a parameter has a sensible default value that most callers will use. You can specify a default in the function definition:

```python
def greet(name, greeting="Hello"):
    print(f"{greeting}, {name}!")


greet("Alice")
greet("Bob", "Good morning")
```

This produces:

```
Hello, Alice!
Good morning, Bob!
```

When the caller omits the `greeting` argument, Python uses the default value `"Hello"`. When the caller provides a value, it overrides the default.

A practical example — a function that formats a price with a configurable currency symbol:

```python
def format_price(amount, currency="$", decimals=2):
    return f"{currency}{amount:.{decimals}f}"


print(format_price(29.99))
print(format_price(29.99, "€"))
print(format_price(29.99, "£", 0))
```

This produces:

```
$29.99
€29.99
£30
```

**Warning:**

Parameters with defaults must come after parameters without defaults. `def greet(greeting="Hello", name):` is a `SyntaxError`. Python would not know which argument maps to which parameter.

## 3.1.5 Keyword arguments

When a function has several parameters, remembering the order becomes difficult. **Keyword arguments** let you specify which parameter each value belongs to, regardless of order:

```python
def create_user(name, age, city):
    print(f"{name}, {age}, from {city}")


# Positional arguments (order matters)
create_user("Alice", 30, "Budapest")

# Keyword arguments (order does not matter)
create_user(city="Prague", name="Bob", age=25)
```

Both calls produce correct output. Keyword arguments make code more readable at the call site, especially when a function has many parameters or when the meaning of arguments is not obvious from their values.

You can mix positional and keyword arguments, but positional arguments must come first:

```python
# Valid: positional first, then keyword
create_user("Charlie", age=28, city="Vienna")

# Invalid: keyword before positional
# create_user(name="Diana", 35, "Berlin")  # SyntaxError
```

**In practice:**

Keyword arguments are common in Python's standard library and third-party packages. When you see a function call like `sorted(data, key=len, reverse=True)`, the `key` and `reverse` are keyword arguments. Using them makes the code self-documenting — you can tell what each value means without reading the function's definition.

## 3.1.6 Variable scope

Variables created inside a function are **local** — they exist only while the function is running and are invisible outside it:

```python
def calculate_tax(amount):
    tax_rate = 0.20
    tax = amount * tax_rate
    return tax


total_tax = calculate_tax(100)
print(f"Tax: ${total_tax}")
# print(tax_rate)  # NameError: 'tax_rate' is not defined
```

The variable `tax_rate` exists only inside `calculate_tax`. Trying to access it outside the function raises a `NameError`.

Variables created outside all functions are **global** — they are accessible everywhere:

```python
app_name = "Invoice Generator"


def show_header():
    print(f"=== {app_name} ===")


show_header()
```

This works because `show_header` reads the global variable `app_name`. However, if you try to modify a global variable inside a function, Python creates a local variable with the same name instead:

```python
counter = 0


def increment():
    counter = counter + 1  # UnboundLocalError


increment()
```

This raises an `UnboundLocalError` because Python sees the assignment to `counter` and treats it as local, but the right side tries to read it before it has been assigned locally. You *can* fix this with the `global` keyword, but the better approach is to avoid global mutable state entirely.

**Tip:**

Pass data into functions as arguments and get results back with `return`. This makes functions self-contained and predictable. A function that depends on global variables is harder to test, reuse, and debug because its behaviour changes based on external state.

**Think about it:**

You have two functions that both need access to a tax rate. You could use a global variable `TAX_RATE = 0.20`, or you could pass the rate as a parameter. What are the advantages and disadvantages of each approach?

## 3.1.7 The DRY principle

**DRY** stands for **Don't Repeat Yourself**. If you find yourself writing the same (or very similar) code in multiple places, extract it into a function:

```python
# BEFORE: repeated logic
price_1 = 49.99
tax_1 = price_1 * 0.20
total_1 = price_1 + tax_1
print(f"Item 1: ${total_1:.2f}")

price_2 = 29.99
tax_2 = price_2 * 0.20
total_2 = price_2 + tax_2
print(f"Item 2: ${total_2:.2f}")

price_3 = 15.50
tax_3 = price_3 * 0.20
total_3 = price_3 + tax_3
print(f"Item 3: ${total_3:.2f}")
```

This works, but the tax calculation is repeated three times. If the tax rate changes, you must update three places. Refactored:

```python
# AFTER: reusable function
def calculate_total(price, tax_rate=0.20):
    tax = price * tax_rate
    return price + tax


prices = [49.99, 29.99, 15.50]
for i, price in enumerate(prices, start=1):
    total = calculate_total(price)
    print(f"Item {i}: ${total:.2f}")
```

The tax logic lives in one place. Changing the rate requires editing one line. Adding a new item requires adding one value to the list. The function can be tested independently.

## 3.1.8 Common pitfalls

**Forgetting parentheses when calling a function**

```python
def get_greeting():
    return "Hello!"


# This prints the function object, not the result
print(get_greeting)    # <function get_greeting at 0x...>

# This calls the function and prints the result
print(get_greeting())  # Hello!
```

Without `()`, you reference the function itself as an object. With `()`, you call it.

**Confusing `print` and `return`**

```python
def add(a, b):
    print(a + b)  # Displays the result but returns None


result = add(3, 4)   # Prints 7
print(result)         # Prints None — the function returned nothing
```

If you need the result for further processing, use `return`:

```python
def add(a, b):
    return a + b


result = add(3, 4)    # result is 7
print(result * 2)     # 14
```

**Using a mutable default argument**

```python
# WRONG: the list is shared across all calls
def add_item(item, items=[]):
    items.append(item)
    return items


print(add_item("apple"))   # ['apple']
print(add_item("banana"))  # ['apple', 'banana'] — unexpected!
```

The default list is created once and reused. Use `None` as the default instead:

```python
def add_item(item, items=None):
    if items is None:
        items = []
    items.append(item)
    return items
```

## Summary

In this chapter, you learned:

- Functions are defined with `def`, called with `()`, and reused throughout your code
- Parameters receive data into a function; `return` sends results back
- Default parameters provide fallback values; keyword arguments improve readability
- Local variables exist only inside their function; global variables are accessible everywhere
- The DRY principle says: if you repeat code, extract it into a function
- Always use `return` (not `print`) when you need to use the result elsewhere
- Avoid mutable default arguments — use `None` and create new objects inside the function

**Key syntax pattern:**

```python
def function_name(param1, param2, param3="default"):
    # function body
    result = param1 + param2
    return result


# Call with positional arguments
value = function_name(10, 20)

# Call with keyword arguments
value = function_name(param1=10, param2=20, param3="custom")
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 3.1: Writing reusable functions**.

In this lab, you will:

- Refactor repeated code into clean, reusable functions
- Write a function library for string validation (email, phone number)
- Practice functions with default and keyword arguments
- Explore scope by experimenting with local and global variables

Open your editor and proceed to Lab 3.1.
