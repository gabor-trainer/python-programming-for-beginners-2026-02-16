# Chapter 3.3: Modules and the standard library

**Reading time**: 25 minutes  
**Topics covered**: `import`, `from ... import`, creating your own modules, standard library modules (`os`, `sys`, `math`, `random`, `datetime`, `pathlib`)  
**Prerequisite reading**: Chapter 3.2  
**Associated lab**: Lab 3.3 - Exploring modules and the standard library

## What you will learn

After reading this chapter, you will be able to:

- Import modules using `import` and `from ... import`
- Create your own module and import it into another script
- Use key standard library modules: `math`, `random`, `datetime`, `pathlib`, `os`, and `sys`
- Explain why organising code into modules improves maintainability
- Distinguish between importing a whole module and importing specific names

## Introduction

Your scripts are getting longer. Functions help organise code within a single file, but at some point, a 500-line script becomes hard to navigate. You find yourself scrolling past utility functions to get to the main logic. You want to reuse your validation functions in a second script but cannot without copying them.

**Modules** solve this. A module is simply a `.py` file that contains functions, variables, and classes that you can import into other files. You have already used one — `import csv` in Chapter 3.2. That single line gave you access to an entire library of CSV-handling code written by the Python team.

Python ships with a vast **standard library**: over 200 modules covering mathematics, dates, file paths, random numbers, networking, JSON parsing, and much more. Learning to navigate this library is one of the most valuable skills a Python developer can build. This chapter teaches you how to import and use modules, and how to create your own.

## 3.3.1 Importing a module

The `import` statement makes a module's contents available in your script:

```python
import math

print(math.pi)
print(math.sqrt(144))
print(math.ceil(4.2))
```

This produces:

```
3.141592653589793
12.0
5
```

After `import math`, you access everything in the module using dot notation: `math.pi`, `math.sqrt()`, `math.ceil()`. The module name acts as a namespace, preventing name conflicts — if you have your own variable called `pi`, it does not clash with `math.pi`.

You can import multiple modules in separate statements:

```python
import math
import random
import datetime
```

**Tip:**

Place all `import` statements at the top of your file, before any other code. This is a PEP 8 convention that makes dependencies visible at a glance.

## 3.3.2 Importing specific names

If you use only one or two functions from a module, you can import them directly:

```python
from math import sqrt, pi

print(pi)
print(sqrt(144))
```

Now you use `sqrt` and `pi` directly, without the `math.` prefix. This is convenient but has a trade-off: if you have a local variable named `pi`, it shadows the imported one.

You can also rename imports with `as`:

```python
from datetime import datetime as dt

now = dt.now()
print(now.strftime("%Y-%m-%d %H:%M"))
```

**Warning:**

Avoid `from module import *` — it imports every name from the module into your namespace. This creates ambiguity (where did `sqrt` come from?) and risks silently overwriting your own variables. Always import specific names or use the `import module` form.

## 3.3.3 The `math` module

The `math` module provides mathematical functions and constants:

```python
import math

# Constants
print(f"Pi: {math.pi}")
print(f"e:  {math.e}")

# Rounding
print(f"ceil(4.2):  {math.ceil(4.2)}")    # 5 (round up)
print(f"floor(4.8): {math.floor(4.8)}")   # 4 (round down)

# Powers and roots
print(f"sqrt(64):   {math.sqrt(64)}")     # 8.0
print(f"pow(2, 10): {math.pow(2, 10)}")   # 1024.0

# Logarithms
print(f"log(100, 10): {math.log(100, 10)}")  # 2.0
```

**Note:**

Python also has built-in `abs()`, `round()`, `pow()`, `min()`, and `max()` that do not require importing `math`. The `math` module adds more specialised functions like `sqrt`, `ceil`, `floor`, `log`, and trigonometric functions.

## 3.3.4 The `random` module

The `random` module generates pseudo-random numbers — essential for simulations, games, testing, and shuffling data:

```python
import random

# Random integer in a range (inclusive)
die_roll = random.randint(1, 6)
print(f"Die roll: {die_roll}")

# Random float between 0.0 and 1.0
probability = random.random()
print(f"Random float: {probability:.4f}")

# Random choice from a list
colors = ["red", "green", "blue", "yellow"]
pick = random.choice(colors)
print(f"Random color: {pick}")

# Shuffle a list in place
cards = ["A", "K", "Q", "J", "10"]
random.shuffle(cards)
print(f"Shuffled: {cards}")

# Random sample without replacement
lottery = random.sample(range(1, 50), 5)
print(f"Lottery numbers: {sorted(lottery)}")
```

Each time you run this script, the output differs because the values are random.

**In practice:**

In real projects, `random` is used for generating test data, simulating user behaviour, implementing game mechanics, and selecting random samples for analysis. For security-sensitive tasks like generating passwords or tokens, use the `secrets` module instead — it produces cryptographically strong random values.

## 3.3.5 The `datetime` module

The `datetime` module handles dates, times, and time differences:

```python
from datetime import datetime, date, timedelta

# Current date and time
now = datetime.now()
print(f"Now: {now}")
print(f"Formatted: {now.strftime('%Y-%m-%d %H:%M:%S')}")

# Create a specific date
birthday = date(1990, 5, 15)
today = date.today()
age_days = (today - birthday).days
print(f"Days since birthday: {age_days}")
print(f"Approximate years: {age_days // 365}")

# Time arithmetic with timedelta
deadline = today + timedelta(days=30)
print(f"Today: {today}")
print(f"Deadline (30 days): {deadline}")

# Parse a date string
date_str = "2025-12-31"
parsed = datetime.strptime(date_str, "%Y-%m-%d")
print(f"Parsed: {parsed.date()}")
```

Key format codes for `strftime` (format to string) and `strptime` (parse from string):

| Code | Meaning | Example |
|------|---------|---------|
| `%Y` | 4-digit year | `2025` |
| `%m` | Month (zero-padded) | `01`–`12` |
| `%d` | Day (zero-padded) | `01`–`31` |
| `%H` | Hour (24-hour) | `00`–`23` |
| `%M` | Minute | `00`–`59` |
| `%S` | Second | `00`–`59` |

**Tip:**

Subtracting two `date` or `datetime` objects produces a `timedelta` object representing the difference. You can access `.days` for the number of days, or use `timedelta` to add or subtract time from a date.

## 3.3.6 The `pathlib` module

The `pathlib` module provides an object-oriented way to work with file system paths. It is cleaner and more portable than string manipulation:

```python
from pathlib import Path

# Create a path object
project_dir = Path("C:/labs/my_project")
print(f"Directory: {project_dir}")
print(f"Exists: {project_dir.exists()}")

# Build paths with the / operator
data_file = project_dir / "data" / "input.csv"
print(f"File path: {data_file}")
print(f"File name: {data_file.name}")
print(f"Extension: {data_file.suffix}")
print(f"Parent dir: {data_file.parent}")

# List files in a directory
current = Path(".")
print(f"\nPython files in current directory:")
for py_file in current.glob("*.py"):
    print(f"  {py_file.name}")

# Read and write files (convenience methods)
output = project_dir / "output.txt"
# output.write_text("Hello from pathlib!\n")
# content = output.read_text()
```

The `/` operator on `Path` objects builds paths correctly on any operating system. No more worrying about backslashes versus forward slashes.

**Key `Path` methods:**

| Method | Purpose |
|--------|---------|
| `Path.exists()` | Check if the path exists |
| `Path.is_file()` | Check if it is a file |
| `Path.is_dir()` | Check if it is a directory |
| `Path.mkdir(parents=True)` | Create directory (and parents) |
| `Path.glob("*.txt")` | Find matching files |
| `Path.read_text()` | Read file content as string |
| `Path.write_text(data)` | Write string to file |
| `Path.name` | File name with extension |
| `Path.stem` | File name without extension |
| `Path.suffix` | File extension (e.g., `.txt`) |
| `Path.parent` | Parent directory |

**Think about it:**

You have been using string paths like `"C:/labs/data/report.txt"` throughout this course. What advantages does `Path("C:/labs/data") / "report.txt"` offer? Consider what happens when you need to change the directory or run the script on a different system.

## 3.3.7 The `os` and `sys` modules

The `os` module interacts with the operating system, and `sys` provides information about the Python runtime:

```python
import os
import sys

# Current working directory
print(f"Working directory: {os.getcwd()}")

# Environment variables
user = os.environ.get("USERNAME", "unknown")
print(f"Current user: {user}")

# Python information
print(f"Python version: {sys.version}")
print(f"Python executable: {sys.executable}")

# Command-line arguments
print(f"Script arguments: {sys.argv}")

# List directory contents
print(f"\nFiles in current directory:")
for entry in os.listdir("."):
    print(f"  {entry}")
```

`sys.argv` is a list of command-line arguments. The first element (`sys.argv[0]`) is always the script name. Additional arguments follow:

```
C:\labs> python myscript.py input.txt output.txt
```

In this case, `sys.argv` would be `["myscript.py", "input.txt", "output.txt"]`.

**Note:**

For file path operations, prefer `pathlib` over `os.path`. The `os` module is still useful for environment variables, process management, and directory operations, but `pathlib` provides a cleaner API for path manipulation.

## 3.3.8 Creating your own modules

Any `.py` file is a module. If you have a file called `utils.py`:

```python
# utils.py - Utility functions

def format_price(amount, currency="$"):
    """Format a number as a price string."""
    return f"{currency}{amount:,.2f}"


def validate_email(email):
    """Basic email validation: must contain @ and a dot after @."""
    if "@" not in email:
        return False
    parts = email.split("@")
    if len(parts) != 2:
        return False
    return "." in parts[1]


TAX_RATE = 0.20
```

You can import it from another file in the same directory:

```python
# main.py
import utils

price = utils.format_price(1299.99)
print(price)

is_valid = utils.validate_email("alice@example.com")
print(f"Valid email: {is_valid}")

print(f"Tax rate: {utils.TAX_RATE}")
```

This produces:

```
$1,299.99
Valid email: True
Tax rate: 0.2
```

You can also import specific names:

```python
from utils import format_price, validate_email

print(format_price(49.99, "€"))
print(validate_email("not-an-email"))
```

**The `if __name__ == "__main__":` pattern**

When Python imports a module, it executes all the code in that file. If `utils.py` contains test code at the bottom, it would run during import:

```python
# utils.py

def format_price(amount, currency="$"):
    return f"{currency}{amount:,.2f}"


# This test code runs when the file is executed directly,
# but NOT when it is imported by another module
if __name__ == "__main__":
    print(format_price(99.99))
    print(format_price(1500, "€"))
```

When you run `python utils.py` directly, `__name__` is `"__main__"` and the test code runs. When another script imports `utils`, `__name__` is `"utils"` and the test code is skipped. This pattern lets you include test code in your modules without it interfering with imports.

## 3.3.9 Common pitfalls

**Circular imports**

If `module_a.py` imports `module_b.py` and `module_b.py` imports `module_a.py`, you get a circular import error. The solution is to restructure your code so the shared functionality lives in a third module that both can import.

**Shadowing module names**

If you create a file called `random.py` in your working directory, `import random` will import your file instead of Python's standard library module. Avoid naming your files after standard library modules.

```python
# If you have a file called "math.py" in C:\labs:
import math    # Imports YOUR math.py, not Python's!
math.sqrt(16)  # AttributeError: module 'math' has no attribute 'sqrt'
```

**Importing from the wrong directory**

Python looks for modules in the current directory first, then in the standard library, then in installed packages. If your module is in a different directory, Python will not find it. Keep your module files in the same directory as the script that imports them (or learn about packages later).

## Summary

In this chapter, you learned:

- `import module` makes a module's contents available with dot notation
- `from module import name` imports specific names directly into your namespace
- Place all imports at the top of the file (PEP 8 convention)
- Python's standard library includes `math` (calculations), `random` (random values), `datetime` (dates and times), `pathlib` (file paths), `os` (operating system), and `sys` (Python runtime)
- Any `.py` file is a module — create your own and import them
- Use `if __name__ == "__main__":` to include test code that runs only when the file is executed directly
- Avoid naming your files after standard library modules

**Key syntax pattern:**

```python
# Import entire module
import math
result = math.sqrt(16)

# Import specific names
from datetime import datetime, timedelta
now = datetime.now()

# Import with alias
from datetime import datetime as dt

# Your own module (same directory)
import utils
price = utils.format_price(29.99)
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 3.3: Exploring modules and the standard library**.

In this lab, you will:

- Use `random` to simulate dice rolls and card drawing
- Use `datetime` to compute date differences and format dates
- Use `pathlib` to list files in a directory and inspect file properties
- Create your own utility module and import it into a main script

Open your editor and proceed to Lab 3.3.
