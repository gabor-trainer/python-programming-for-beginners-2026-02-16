# Chapter 4.2: Introduction to object-oriented programming

**Reading time**: 25 minutes  
**Topics covered**: Classes, `__init__`, instance attributes, methods, `__str__`, objects as data containers  
**Prerequisite reading**: Chapter 4.1  
**Associated lab**: Lab 4.2 - Creating your first classes

## What you will learn

After reading this chapter, you will be able to:

- Define a class with `class` and create instances from it
- Use `__init__` to initialize object attributes
- Write methods that operate on instance data
- Implement `__str__` to control how objects are displayed
- Recognize when grouping data and behavior into a class simplifies your code

## Introduction

So far, you have organized data using built-in types: strings, numbers, lists, and dictionaries. These work well for many tasks, but they have limits. Consider a contact book application: each contact has a name, email, and phone number. You could store each contact as a dictionary, but then every function that works with contacts needs to know the exact key names. Nothing prevents you from misspelling `"emial"` instead of `"email"`. And the functions that validate, format, and display contacts are scattered across your code with no clear connection to the data they operate on.

**Object-oriented programming** (OOP) addresses this by letting you define your own data types. A **class** is a blueprint that bundles data (attributes) and behavior (methods) into a single unit. An **object** is a specific instance created from that blueprint. Instead of a dictionary with keys you have to remember, you get an object with clearly defined attributes and methods that belong to it.

This chapter introduces the basics: defining classes, initializing attributes, writing methods, and controlling how objects are printed. The goal is awareness and practical comfort — not mastery. OOP is a deep topic, and what you learn here will give you a solid foundation for further exploration.

## 4.2.1 What is a class?

A **class** defines a new type. Think of it as a template that describes what data an object holds and what operations it supports. You create a class with the `class` keyword:

```python
class Contact:
    pass
```

This creates a class called `Contact` that does nothing yet. The `pass` statement is a placeholder — it tells Python the body is intentionally empty.

You create an **object** (also called an **instance**) by calling the class like a function:

```python
alice = Contact()
bob = Contact()

print(type(alice))
print(alice is bob)
```

This produces:

```
<class '__main__.Contact'>
False
```

Each call to `Contact()` creates a new, independent object. `alice` and `bob` are both `Contact` instances, but they are separate objects in memory.

**Key terms:**

- **Class**: A blueprint that defines a type (the template)
- **Object / Instance**: A specific thing created from a class (the product)
- **Attribute**: A variable that belongs to an object (its data)
- **Method**: A function that belongs to a class (its behavior)

The convention for class names in Python is **PascalCase**: each word starts with a capital letter, no underscores. This distinguishes classes from variables and functions, which use snake_case.

## 4.2.2 The `__init__` method

A class without data is not useful. The `__init__` method (short for "initialize") runs automatically when you create a new object. It sets up the object's initial state:

```python
class Contact:
    def __init__(self, name, email, phone):
        self.name = name
        self.email = email
        self.phone = phone
```

Let us break this down:

- `def __init__(self, name, email, phone):` — This is a method definition. The first parameter, `self`, refers to the object being created. Python passes it automatically; you never provide it in the call.
- `self.name = name` — This creates an **instance attribute** called `name` on the object and assigns the value of the `name` parameter to it.

Now you can create contacts with data:

```python
alice = Contact("Alice Novak", "alice@example.com", "+420 123 456 789")
bob = Contact("Bob Dvorak", "bob@example.com", "+420 987 654 321")

print(alice.name)
print(bob.email)
```

This produces:

```
Alice Novak
bob@example.com
```

You access an object's attributes with dot notation: `object.attribute`. Each object has its own separate copy of the attributes — changing `alice.phone` does not affect `bob.phone`.

**Note:**

The double underscores in `__init__` mark it as a **special method** (sometimes called a "dunder method" — short for "double underscore"). Python uses special methods for built-in operations. You will see another one, `__str__`, later in this chapter. You do not call `__init__` directly; Python calls it for you when you create an object.

## 4.2.3 Comparing classes to dictionaries

You might wonder why you need classes when dictionaries can hold the same data. Here is the dictionary approach:

```python
alice = {"name": "Alice Novak", "email": "alice@example.com", "phone": "+420 123 456 789"}

print(alice["name"])
```

And the class approach:

```python
alice = Contact("Alice Novak", "alice@example.com", "+420 123 456 789")

print(alice.name)
```

Both work. So why bother with a class? Several reasons:

| Aspect | Dictionary | Class |
|--------|-----------|-------|
| Structure | Keys are strings — typos are silent bugs | Attributes defined in `__init__` — typos cause `AttributeError` |
| Validation | None by default | You can validate in `__init__` |
| Behavior | Functions are separate from data | Methods live with the data they operate on |
| Readability | `contact["email"]` | `contact.email` |
| IDE support | No autocomplete for keys | Autocomplete shows available attributes |

For quick, throwaway data, dictionaries are fine. When you are building something with structure — a contact book, an expense tracker, a product catalog — classes make your code clearer and less error-prone.

**Think about it:**

Imagine you have a list of 50 contacts stored as dictionaries. You discover that one dictionary has the key `"emial"` instead of `"email"`. How would you find this bug? Now imagine the same scenario with a `Contact` class — what happens if you try to set `self.emial` instead of `self.email`?

With dictionaries, the misspelled key silently creates a new entry. With a class, you would notice because `contact.email` would be missing or raise an error when accessed. The class provides structure that catches mistakes earlier.

## 4.2.4 Writing methods

A **method** is a function defined inside a class. It always takes `self` as its first parameter, giving it access to the object's attributes:

```python
class Contact:
    def __init__(self, name, email, phone):
        self.name = name
        self.email = email
        self.phone = phone

    def format_label(self):
        return f"{self.name} <{self.email}>"

    def has_valid_email(self):
        return "@" in self.email and "." in self.email
```

You call methods with dot notation, just like attributes — but with parentheses:

```python
alice = Contact("Alice Novak", "alice@example.com", "+420 123 456 789")

print(alice.format_label())
print(alice.has_valid_email())
```

This produces:

```
Alice Novak <alice@example.com>
True
```

When you call `alice.format_label()`, Python automatically passes `alice` as the `self` parameter. Inside the method, `self.name` refers to `"Alice Novak"` and `self.email` refers to `"alice@example.com"`.

Methods can also accept additional parameters beyond `self`:

```python
class Contact:
    def __init__(self, name, email, phone):
        self.name = name
        self.email = email
        self.phone = phone

    def matches_search(self, query):
        query_lower = query.lower()
        return (
            query_lower in self.name.lower()
            or query_lower in self.email.lower()
        )
```

```python
alice = Contact("Alice Novak", "alice@example.com", "+420 123 456 789")

print(alice.matches_search("alice"))
print(alice.matches_search("bob"))
```

```
True
False
```

**Tip:**

Methods let you keep related logic together with the data it operates on. Instead of writing a standalone `format_contact_label(contact_dict)` function, you write `contact.format_label()`. The data and the behavior that belongs to it live in the same place.

## 4.2.5 The `__str__` method

When you print an object, Python shows its type and memory address by default — not useful:

```python
alice = Contact("Alice Novak", "alice@example.com", "+420 123 456 789")
print(alice)
```

```
<__main__.Contact object at 0x000001A2B3C4D5E6>
```

The `__str__` special method lets you define a human-readable string representation. Python calls it automatically when you use `print()` or `str()`:

```python
class Contact:
    def __init__(self, name, email, phone):
        self.name = name
        self.email = email
        self.phone = phone

    def __str__(self):
        return f"Contact({self.name}, {self.email}, {self.phone})"
```

Now printing shows something meaningful:

```python
alice = Contact("Alice Novak", "alice@example.com", "+420 123 456 789")
print(alice)
```

```
Contact(Alice Novak, alice@example.com, +420 123 456 789)
```

This is especially useful when you have a list of objects:

```python
contacts = [
    Contact("Alice Novak", "alice@example.com", "+420 123 456 789"),
    Contact("Bob Dvorak", "bob@example.com", "+420 987 654 321"),
]

for contact in contacts:
    print(contact)
```

```
Contact(Alice Novak, alice@example.com, +420 123 456 789)
Contact(Bob Dvorak, bob@example.com, +420 987 654 321)
```

Without `__str__`, this would print two lines of unreadable memory addresses.

## 4.2.6 Building a complete class

Let us put everything together and build a `ContactBook` class that manages a collection of contacts:

```python
class Contact:
    def __init__(self, name, email, phone):
        self.name = name
        self.email = email
        self.phone = phone

    def __str__(self):
        return f"{self.name} | {self.email} | {self.phone}"


class ContactBook:
    def __init__(self):
        self.contacts = []

    def add(self, contact):
        self.contacts.append(contact)
        print(f"Added: {contact.name}")

    def search(self, query):
        query_lower = query.lower()
        results = [
            c for c in self.contacts
            if query_lower in c.name.lower()
            or query_lower in c.email.lower()
        ]
        return results

    def show_all(self):
        if not self.contacts:
            print("Contact book is empty.")
            return
        for contact in self.contacts:
            print(contact)

    def __str__(self):
        return f"ContactBook({len(self.contacts)} contacts)"
```

Using it:

```python
book = ContactBook()

book.add(Contact("Alice Novak", "alice@example.com", "+420 123 456 789"))
book.add(Contact("Bob Dvorak", "bob@example.com", "+420 987 654 321"))
book.add(Contact("Charlie Svoboda", "charlie@example.com", "+420 555 666 777"))

print(book)
print()

book.show_all()
print()

results = book.search("alice")
print(f"Found {len(results)} result(s):")
for contact in results:
    print(f"  {contact}")
```

This produces:

```
Added: Alice Novak
Added: Bob Dvorak
Added: Charlie Svoboda
ContactBook(3 contacts)

Alice Novak | alice@example.com | +420 123 456 789
Bob Dvorak | bob@example.com | +420 987 654 321
Charlie Svoboda | charlie@example.com | +420 555 666 777

Found 1 result(s):
  Alice Novak | alice@example.com | +420 123 456 789
```

Notice how the `ContactBook` uses a list internally, but the user of the class does not need to know that. They interact with `add()`, `search()`, and `show_all()`. The internal details are hidden behind a clean interface.

**In practice:**

This pattern — a class that manages a collection of other objects — is extremely common. A `ShoppingCart` that holds `Product` objects. An `Inbox` that holds `Email` objects. A `Playlist` that holds `Song` objects. Once you recognize the pattern, you can apply it everywhere.

## 4.2.7 Common pitfalls

**Forgetting `self`**

Every method must have `self` as its first parameter. Forgetting it produces a confusing error:

```python
class Contact:
    def __init__(name, email, phone):  # Missing self!
        self.name = name  # NameError: 'self' is not defined
```

Always include `self` as the first parameter of every method.

**Forgetting `self.` when accessing attributes**

Inside a method, you must use `self.name` to access the object's attribute. Using just `name` refers to the local parameter or causes a `NameError`:

```python
class Contact:
    def __init__(self, name, email, phone):
        self.name = name
        self.email = email
        self.phone = phone

    def greet(self):
        # Wrong — 'name' is not defined in this scope
        # print(f"Hello, {name}")

        # Correct — use self.name
        print(f"Hello, {self.name}")
```

**Confusing the class with an instance**

The class is the blueprint; the instance is the object. You do not call methods on the class itself:

```python
# Wrong — Contact is the class, not an instance
# Contact.format_label()

# Correct — call methods on an instance
alice = Contact("Alice", "alice@example.com", "+420 123 456 789")
alice.format_label()
```

**Trying to print objects without `__str__`**

If you see output like `<__main__.Contact object at 0x...>`, your class is missing a `__str__` method. Add one to get readable output.

## Summary

In this chapter, you learned:

- A class is a blueprint that bundles data (attributes) and behavior (methods) into a single type
- `__init__` runs automatically when creating an object and sets up its initial attributes
- Instance attributes are accessed with dot notation: `object.attribute`
- Methods are functions defined in a class that operate on the object's data through `self`
- `__str__` controls how an object is displayed when printed
- Classes are preferable to dictionaries when you need structure, validation, and behavior tied to data

**Key syntax patterns:**

```python
# Define a class
class MyClass:
    def __init__(self, param1, param2):
        self.attr1 = param1
        self.attr2 = param2

    def my_method(self):
        return f"{self.attr1}: {self.attr2}"

    def __str__(self):
        return f"MyClass({self.attr1}, {self.attr2})"


# Create and use an instance
obj = MyClass("value1", "value2")
print(obj.my_method())
print(obj)
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 4.2: Creating your first classes**.

In this lab, you will:

- Create a `Contact` class with name, email, and phone attributes
- Add methods to format and validate contact data
- Build a `ContactBook` class that stores contacts in a list
- Use `__str__` for readable output
- Combine classes with list comprehensions from Chapter 4.1

Open your editor and proceed to Lab 4.2.
