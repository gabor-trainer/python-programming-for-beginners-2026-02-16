# Chapter 4.1: List comprehensions and generator expressions

**Reading time**: 25 minutes  
**Topics covered**: List comprehensions, conditional filtering, nested comprehensions, dictionary comprehensions, generator expressions  
**Prerequisite reading**: Chapter 3.4  
**Associated lab**: Lab 4.1 - Pythonic data transformation

## What you will learn

After reading this chapter, you will be able to:

- Write list comprehensions to create new lists from existing iterables
- Add conditions to comprehensions to filter data
- Use nested comprehensions for multi-level data processing
- Build dictionaries with dictionary comprehensions
- Use generator expressions for memory-efficient processing of large datasets

## Introduction

Throughout this course you have used `for` loops to build new lists: iterate over a collection, apply some logic, and append results to an accumulator list. It works, but it is verbose. Five lines of code to express what is really a single idea — "give me the squares of all even numbers."

Python offers a more concise and expressive tool for exactly this pattern: the **list comprehension**. A list comprehension lets you describe the result you want in a single line, and Python builds the list for you. It is not just shorter — it clearly communicates your intent. When experienced Python developers see a list comprehension, they immediately understand what data transformation is happening.

This chapter also introduces **dictionary comprehensions** for building dictionaries and **generator expressions** for processing data without loading everything into memory at once. These tools are central to writing idiomatic Python — code that looks and feels the way Python was designed to be used.

## 4.1.1 From loops to comprehensions

Consider a common task: given a list of prices, create a new list with a 10% discount applied to each. Here is the traditional loop approach:

```python
prices = [100, 250, 50, 300, 75]

discounted = []
for price in prices:
    discounted.append(price * 0.9)

print(discounted)
```

This produces:

```
[90.0, 225.0, 45.0, 270.0, 67.5]
```

The pattern is always the same: create an empty list, loop, append. A **list comprehension** collapses this into a single expression:

```python
prices = [100, 250, 50, 300, 75]

discounted = [price * 0.9 for price in prices]

print(discounted)
```

This produces the same output:

```
[90.0, 225.0, 45.0, 270.0, 67.5]
```

The syntax reads almost like English: "give me `price * 0.9` for each `price` in `prices`." The general form is:

```python
result = [expression for variable in iterable]
```

Where:
- **expression** — what to compute for each element (e.g., `price * 0.9`)
- **variable** — the loop variable that takes each value from the iterable
- **iterable** — the source collection (list, range, file, etc.)

Here is another example — converting a list of names to uppercase:

```python
names = ["alice", "bob", "charlie"]
upper_names = [name.upper() for name in names]
print(upper_names)
```

This produces:

```
['ALICE', 'BOB', 'CHARLIE']
```

And extracting the first character from each name:

```python
initials = [name[0].upper() for name in names]
print(initials)
```

This produces:

```
['A', 'B', 'C']
```

**Tip:**

List comprehensions work with any iterable, including `range()`. To create a list of squares from 1 to 10:

```python
squares = [n ** 2 for n in range(1, 11)]
print(squares)
```

```
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

## 4.1.2 Filtering with conditions

Often you do not want every element — only those that meet a criterion. The loop approach uses an `if` inside the body:

```python
scores = [85, 42, 91, 67, 55, 78, 95, 38]

passing = []
for score in scores:
    if score >= 60:
        passing.append(score)

print(passing)
```

This produces:

```
[85, 91, 67, 78, 95]
```

A list comprehension can include an `if` clause to filter:

```python
scores = [85, 42, 91, 67, 55, 78, 95, 38]

passing = [score for score in scores if score >= 60]

print(passing)
```

Same result, one line. The general form with a condition is:

```python
result = [expression for variable in iterable if condition]
```

Python evaluates the condition for each element and only includes those where it is `True`.

You can combine transformation and filtering in a single comprehension. For example, extract the lengths of words that are longer than three characters:

```python
words = ["I", "am", "learning", "Python", "comprehensions", "now"]

long_lengths = [len(word) for word in words if len(word) > 3]
print(long_lengths)
```

This produces:

```
[8, 6, 14]
```

**In practice:**

Filtering with comprehensions is extremely common in data processing. Imagine reading a CSV file and extracting only the rows where sales exceed a threshold, or filtering a list of filenames to include only `.csv` files:

```python
files = ["report.csv", "image.png", "data.csv", "notes.txt", "sales.csv"]
csv_files = [f for f in files if f.endswith(".csv")]
print(csv_files)
```

```
['report.csv', 'data.csv', 'sales.csv']
```

## 4.1.3 Comprehensions with if/else

The filtering pattern from the previous section *excludes* elements that do not match. Sometimes you want to *transform differently* based on a condition — include every element, but change some of them. For this, you place the `if`/`else` in the expression part, before `for`:

```python
scores = [85, 42, 91, 67, 55, 78, 95, 38]

labels = ["pass" if score >= 60 else "fail" for score in scores]
print(labels)
```

This produces:

```
['pass', 'fail', 'pass', 'pass', 'fail', 'pass', 'pass', 'fail']
```

Notice the difference in placement:

- **Filtering** (after `for`): `[x for x in items if condition]` — excludes items
- **Conditional expression** (before `for`): `[a if condition else b for x in items]` — includes all items, transforms conditionally

This is Python's ternary expression: `value_if_true if condition else value_if_false`. You already know it from Chapter 2.3 — here it sits inside a comprehension.

Another practical example — capping values at a maximum:

```python
readings = [12, 45, 102, 67, 200, 89, 150]

capped = [min(reading, 100) for reading in readings]
print(capped)
```

```
[12, 45, 100, 67, 100, 89, 100]
```

**Think about it:**

You have a list of temperatures in Celsius: `[15, -3, 22, 0, -10, 35]`. How would you write a comprehension that produces `"warm"` for temperatures above 20, `"cold"` for temperatures below 0, and `"mild"` for everything else? Can a single list comprehension handle three categories?

The answer: a single comprehension can chain ternary expressions, but it quickly becomes hard to read. When the logic has more than two branches, a separate function is clearer:

```python
def classify(temp):
    if temp > 20:
        return "warm"
    elif temp < 0:
        return "cold"
    else:
        return "mild"


temps = [15, -3, 22, 0, -10, 35]
labels = [classify(t) for t in temps]
print(labels)
```

```
['mild', 'cold', 'warm', 'mild', 'cold', 'warm']
```

This combines a comprehension with a function — readable, testable, and easy to extend.

## 4.1.4 Nested comprehensions

Some tasks involve nested data structures. Consider a matrix represented as a list of lists:

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
]
```

To flatten this into a single list, the loop version uses two nested `for` loops:

```python
flat = []
for row in matrix:
    for value in row:
        flat.append(value)

print(flat)
```

```
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

A nested comprehension does this in one line:

```python
flat = [value for row in matrix for value in row]
print(flat)
```

```
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Read it left to right: "for each `row` in `matrix`, for each `value` in `row`, give me `value`." The order of the `for` clauses matches the nesting order of the equivalent loops.

You can also create nested structures. For example, generating a multiplication table:

```python
table = [[row * col for col in range(1, 6)] for row in range(1, 6)]

for row in table:
    print(row)
```

```
[1, 2, 3, 4, 5]
[2, 4, 6, 8, 10]
[3, 6, 9, 12, 15]
[4, 8, 12, 16, 20]
[5, 10, 15, 20, 25]
```

Here, the outer comprehension creates each row, and the inner comprehension creates the values within each row.

**Warning:**

Nested comprehensions can become difficult to read quickly. As a rule of thumb, if you need more than two levels of nesting or your comprehension exceeds 80 characters, rewrite it as a regular loop. Clarity always beats brevity.

## 4.1.5 Dictionary comprehensions

Just as list comprehensions build lists, **dictionary comprehensions** build dictionaries. The syntax uses curly braces and a `key: value` expression:

```python
words = ["apple", "banana", "cherry", "date"]

word_lengths = {word: len(word) for word in words}
print(word_lengths)
```

This produces:

```
{'apple': 5, 'banana': 6, 'cherry': 6, 'date': 4}
```

The general form is:

```python
result = {key_expr: value_expr for variable in iterable}
```

You can add conditions, just like list comprehensions:

```python
scores = {"Alice": 85, "Bob": 42, "Charlie": 91, "Diana": 55}

passed = {name: score for name, score in scores.items() if score >= 60}
print(passed)
```

```
{'Alice': 85, 'Charlie': 91}
```

Dictionary comprehensions are useful when you need to transform or invert a dictionary. For example, swapping keys and values:

```python
country_codes = {"CZ": "Czech Republic", "SK": "Slovakia", "PL": "Poland"}

name_to_code = {name: code for code, name in country_codes.items()}
print(name_to_code)
```

```
{'Czech Republic': 'CZ', 'Slovakia': 'SK', 'Poland': 'PL'}
```

Or building a dictionary from two parallel lists using `zip()`:

```python
products = ["Apples", "Bananas", "Cherries"]
prices = [25, 15, 40]

catalog = {product: price for product, price in zip(products, prices)}
print(catalog)
```

```
{'Apples': 25, 'Bananas': 15, 'Cherries': 40}
```

**Note:**

There is also a **set comprehension**, which uses curly braces without a colon: `{expression for variable in iterable}`. It works exactly like a list comprehension but produces a set (unique values, no order).

```python
words = ["hello", "world", "hello", "python", "world"]
unique_lengths = {len(word) for word in words}
print(unique_lengths)
```

```
{5, 6}
```

## 4.1.6 Generator expressions

List comprehensions are convenient, but they build the entire result list in memory at once. For small datasets this is fine. For large ones — say, processing a million-line log file — it can consume significant memory.

A **generator expression** looks almost identical to a list comprehension, but uses parentheses instead of square brackets:

```python
# List comprehension — builds entire list in memory
squares_list = [n ** 2 for n in range(1_000_000)]

# Generator expression — produces values one at a time
squares_gen = (n ** 2 for n in range(1_000_000))
```

The generator does not compute all values up front. It produces each value on demand, as you iterate over it:

```python
squares_gen = (n ** 2 for n in range(10))

for square in squares_gen:
    print(square, end=" ")
```

```
0 1 4 9 16 25 36 49 64 81
```

The key advantage is memory efficiency. A list of one million squares occupies roughly 8 MB of memory. A generator expression uses almost none — it generates each value only when asked for the next one.

You can pass a generator expression directly to functions that accept iterables:

```python
# Sum of squares from 1 to 1,000,000
total = sum(n ** 2 for n in range(1, 1_000_001))
print(f"Sum of squares: {total}")
```

```
Sum of squares: 333333833333500000
```

Notice the parentheses: when a generator expression is the only argument to a function, you do not need double parentheses — `sum(...)` is enough, no need for `sum((...))`.

To compare memory usage, you can use the `sys` module:

```python
import sys

list_comp = [n ** 2 for n in range(100_000)]
gen_expr = (n ** 2 for n in range(100_000))

print(f"List size: {sys.getsizeof(list_comp):,} bytes")
print(f"Generator size: {sys.getsizeof(gen_expr):,} bytes")
```

This produces something like:

```
List size: 800,984 bytes
Generator size: 200 bytes
```

The difference is dramatic. The list stores all 100,000 values. The generator stores only the logic to produce them.

**Think about it:**

If a generator expression is so much more memory-efficient, why not always use generators instead of lists? Think about what operations you can do with a list that you cannot do with a generator. What happens if you try to access the third element of a generator with indexing?

The answer: generators can only be iterated once, and they do not support indexing, slicing, or `len()`. Once consumed, a generator is empty. Lists are the right choice when you need random access or when you need to iterate multiple times.

**In practice:**

Generator expressions are valuable when processing data pipelines — reading large files line by line, transforming each line, and writing results. You can chain generators together without ever holding the entire dataset in memory:

```python
# Process a large file efficiently
with open("access.log") as f:
    lines = (line.strip() for line in f)
    errors = (line for line in lines if "ERROR" in line)
    for error_line in errors:
        print(error_line)
```

Each line is read, stripped, filtered, and printed one at a time. Even a multi-gigabyte log file would use minimal memory.

## 4.1.7 Common pitfalls

**Overcomplicating comprehensions**

It is tempting to pack as much logic as possible into a single comprehension. Resist the temptation. If a comprehension requires nested ternary expressions, multiple `for` clauses, and a filter condition, it is harder to understand than the equivalent loop:

```python
# Too complex — hard to read and debug
result = [
    transform(x, y)
    for x in data
    if validate(x)
    for y in x.items
    if y.active
]

# Clearer — use a regular loop
result = []
for x in data:
    if validate(x):
        for y in x.items:
            if y.active:
                result.append(transform(x, y))
```

A good guideline: if your comprehension does not fit on one line (roughly 80 characters), consider using a loop.

**Forgetting that generators are single-use**

A generator expression can only be iterated once. After that, it is exhausted:

```python
gen = (n ** 2 for n in range(5))

print(list(gen))  # [0, 1, 4, 9, 16]
print(list(gen))  # [] — empty, already consumed
```

If you need to iterate multiple times, use a list comprehension instead, or create the generator again.

**Using comprehensions for side effects**

Comprehensions are designed to produce values, not to perform actions. Do not use a list comprehension just to call a function for its side effects:

```python
# Bad — creates a list you never use
[print(item) for item in items]

# Good — use a regular loop
for item in items:
    print(item)
```

The list comprehension version builds a list of `None` values (since `print` returns `None`), wastes memory, and is harder to read.

## Summary

In this chapter, you learned:

- List comprehensions provide a concise way to build lists from existing iterables using the pattern `[expression for variable in iterable]`
- Adding `if condition` after the `for` clause filters elements from the result
- Placing `if`/`else` before `for` applies a conditional transformation to every element
- Dictionary comprehensions use `{key: value for variable in iterable}` to build dictionaries
- Generator expressions use parentheses instead of brackets and produce values on demand, saving memory
- Comprehensions should remain readable — when they grow complex, a regular loop is better

**Key syntax patterns:**

```python
# List comprehension
result = [expression for item in iterable]

# List comprehension with filter
result = [expression for item in iterable if condition]

# Conditional expression in comprehension
result = [a if condition else b for item in iterable]

# Dictionary comprehension
result = {key: value for item in iterable}

# Generator expression
result = (expression for item in iterable)
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 4.1: Pythonic data transformation**.

In this lab, you will:

- Rewrite traditional `for` loops as list comprehensions
- Filter and transform data loaded from files
- Build dictionaries from lists using dictionary comprehensions
- Compare memory usage between list comprehensions and generator expressions
- Chain generators to process data efficiently

Open your editor and proceed to Lab 4.1.
