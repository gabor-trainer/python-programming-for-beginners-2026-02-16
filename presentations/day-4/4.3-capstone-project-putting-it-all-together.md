# Chapter 4.3: Capstone project — putting it all together

**Reading time**: 20 minutes  
**Topics covered**: Project design, combining file I/O with data structures, menu-driven interfaces, modular code organization, project setup with uv  
**Prerequisite reading**: Chapter 4.2  
**Associated lab**: Lab 4.3 - Capstone — build a complete application

## What you will learn

After reading this chapter, you will be able to:

- Plan and structure a multi-file Python project
- Combine file I/O, data structures, functions, error handling, and classes in a single application
- Design a menu-driven command-line interface
- Organize code into logical modules
- Set up a project with uv and `pyproject.toml`

## Introduction

Over the past four days, you have learned individual skills: variables, data structures, loops, functions, file I/O, error handling, modules, comprehensions, and classes. Each one is useful on its own, but the real power of programming comes from combining them into complete applications that solve real problems.

This chapter walks you through the design of a command-line expense tracker — the kind of practical tool you might actually build for yourself. It is not a toy example. It reads and writes CSV files, stores data in dictionaries and lists, validates user input, handles errors, and organizes logic into functions and classes. Every concept from this course appears somewhere in the application.

The goal is not to memorize this specific project, but to see how the pieces fit together. Once you understand the pattern, you can apply it to any project: a contact manager, a recipe book, an inventory system, or anything else you need.

## 4.3.1 Project overview

The expense tracker lets users:

- Add new expenses (date, category, amount, description)
- View all expenses or filter by category
- See a summary with totals per category
- Save data to a CSV file and load it on startup
- Exit the application (data is saved automatically)

Here is what a session might look like:

```
=== Expense tracker ===

1. Add expense
2. View expenses
3. View summary
4. Exit

Choose an option: 1
Date (YYYY-MM-DD): 2024-11-15
Category: food
Amount: 285.50
Description: Weekly groceries
Expense added.

Choose an option: 3

Category summary:
  food: 285.50 CZK
  transport: 150.00 CZK
  entertainment: 200.00 CZK
Total: 635.50 CZK

Choose an option: 4
Data saved. Goodbye.
```

This is a complete, useful application. Let us examine how to build it.

## 4.3.2 Planning the structure

Before writing any code, plan the structure. A well-organized project separates concerns: data storage is distinct from user interaction, which is distinct from business logic.

For the expense tracker, a reasonable structure is:

```
expense-tracker/
    pyproject.toml
    expenses.csv
    main.py
    expense.py
    storage.py
```

| File | Responsibility |
|------|---------------|
| `main.py` | Entry point — runs the menu loop |
| `expense.py` | `Expense` class — represents a single expense |
| `storage.py` | Functions for reading/writing CSV data |
| `expenses.csv` | Data file — created automatically |
| `pyproject.toml` | Project metadata — created by uv |

You set up the project with uv:

```
uv init expense-tracker
cd expense-tracker
```

This creates the `pyproject.toml` and basic project structure. For this application, no external packages are needed — only the Python standard library.

**Tip:**

Even for small projects, separating code into multiple files pays off. Each file is shorter, has a clear purpose, and can be understood independently. When you come back to the project in three months, you will know exactly where to look.

## 4.3.3 Designing the data model

The `Expense` class represents a single expense. It holds the data and knows how to display itself:

```python
class Expense:
    def __init__(self, date, category, amount, description):
        self.date = date
        self.category = category
        self.amount = amount
        self.description = description

    def __str__(self):
        return f"{self.date} | {self.category:<15} | {self.amount:>8.2f} CZK | {self.description}"
```

A few design decisions worth noting:

- `amount` is stored as a `float`. For a production financial application you would use the `decimal` module, but `float` is sufficient for learning.
- The `__str__` method uses format specifiers: `:<15` left-aligns the category in a 15-character field, `:>8.2f` right-aligns the amount with two decimal places. This produces neatly aligned columns.
- The class does not validate data — that is the caller's responsibility. You could add validation here, but keeping the class simple makes it easier to understand.

You can use list comprehensions (Chapter 4.1) to work with collections of expenses:

```python
expenses = [...]  # list of Expense objects

# Filter by category
food = [e for e in expenses if e.category == "food"]

# Total spending
total = sum(e.amount for e in expenses)

# Unique categories
categories = {e.category for e in expenses}
```

This is where comprehensions and classes work together naturally.

## 4.3.4 Reading and writing CSV files

The storage module handles persistence — loading expenses from a CSV file at startup and saving them when the application exits:

```python
import csv
from expense import Expense


def load_expenses(filepath):
    expenses = []
    try:
        with open(filepath, newline="") as f:
            reader = csv.reader(f)
            next(reader)  # Skip header row
            for row in reader:
                date, category, amount, description = row
                expense = Expense(date, category, float(amount), description)
                expenses.append(expense)
    except FileNotFoundError:
        pass  # No file yet — return empty list
    return expenses


def save_expenses(filepath, expenses):
    with open(filepath, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["date", "category", "amount", "description"])
        for expense in expenses:
            writer.writerow([
                expense.date,
                expense.category,
                expense.amount,
                expense.description,
            ])
```

Notice how multiple concepts come together:

- **File I/O** (Chapter 3.2): `open()`, `with` statement, reading and writing
- **CSV processing** (Chapter 3.2): `csv.reader`, `csv.writer`
- **Error handling** (Chapter 3.4): `try`/`except FileNotFoundError` for the first run when no file exists
- **Modules** (Chapter 3.3): importing `csv` and the `Expense` class from another file
- **Classes** (Chapter 4.2): creating `Expense` objects from CSV rows

## 4.3.5 Building the menu interface

The main module ties everything together with a menu-driven loop. The user sees numbered options, enters a choice, and the program dispatches to the appropriate function:

```python
from expense import Expense
from storage import load_expenses, save_expenses

DATA_FILE = "expenses.csv"


def get_menu_choice():
    print("\n=== Expense tracker ===\n")
    print("1. Add expense")
    print("2. View expenses")
    print("3. View summary")
    print("4. Exit")
    return input("\nChoose an option: ").strip()


def add_expense(expenses):
    date = input("Date (YYYY-MM-DD): ").strip()
    category = input("Category: ").strip().lower()
    try:
        amount = float(input("Amount: ").strip())
    except ValueError:
        print("Invalid amount. Expense not added.")
        return
    description = input("Description: ").strip()

    expense = Expense(date, category, amount, description)
    expenses.append(expense)
    print("Expense added.")


def view_expenses(expenses):
    if not expenses:
        print("No expenses recorded.")
        return
    for expense in expenses:
        print(expense)


def view_summary(expenses):
    if not expenses:
        print("No expenses recorded.")
        return

    totals = {}
    for expense in expenses:
        totals[expense.category] = totals.get(expense.category, 0) + expense.amount

    print("\nCategory summary:")
    for category, total in sorted(totals.items()):
        print(f"  {category}: {total:.2f} CZK")
    print(f"Total: {sum(totals.values()):.2f} CZK")


def main():
    expenses = load_expenses(DATA_FILE)
    print(f"Loaded {len(expenses)} expense(s) from {DATA_FILE}.")

    while True:
        choice = get_menu_choice()

        if choice == "1":
            add_expense(expenses)
        elif choice == "2":
            view_expenses(expenses)
        elif choice == "3":
            view_summary(expenses)
        elif choice == "4":
            save_expenses(DATA_FILE, expenses)
            print("Data saved. Goodbye.")
            break
        else:
            print("Invalid choice. Please enter 1-4.")


main()
```

This is the longest piece of code in the course, but each function is short, focused, and understandable on its own. The `main()` function is just a loop that reads a choice and calls the right function.

**In practice:**

This menu-loop pattern is a standard approach for command-line applications. You will see it in tutorials, open-source tools, and production utilities. The structure scales: adding a new feature means writing one new function and adding one `elif` branch.

## 4.3.6 What makes this a "real" project

Step back and look at what this application uses:

| Concept | Where it appears |
|---------|-----------------|
| Variables and data types | Throughout — strings, floats, lists, dictionaries |
| String formatting | f-strings in `__str__`, menu display, summaries |
| Lists | Storing expenses in memory |
| Dictionaries | Category totals in `view_summary` |
| Loops | Menu loop, iterating over expenses |
| Conditionals | Menu dispatch, input validation |
| Functions | Each action is a separate function |
| File I/O | CSV reading and writing |
| Error handling | `try`/`except` for file loading and input validation |
| Modules | Code split across three files with imports |
| Classes | `Expense` class for structured data |
| Comprehensions | Filtering and aggregating expenses |
| uv / pyproject.toml | Project setup and metadata |

Every concept from the course appears naturally, not as a forced exercise but as a genuine part of the solution. This is what programming looks like in practice — combining tools to solve a problem.

**Think about it:**

What would you add to this expense tracker to make it more useful? Consider: date validation, expense editing and deletion, monthly reports, export to different formats, or a configuration file for the currency symbol. Each improvement uses skills you already have.

## 4.3.7 Common pitfalls in project design

**Putting everything in one file**

It is tempting to write the entire application in a single file. For 50 lines, that is fine. For 200+ lines, it becomes hard to navigate and maintain. Splitting into modules with clear responsibilities makes the code manageable.

**Skipping error handling**

An application that crashes on invalid input is frustrating to use. Every point where external data enters your program — user input, file reading, network requests — is a potential failure point. Handle errors at these boundaries.

**Not saving data**

A common mistake in beginner projects is keeping data only in memory. When the program exits, everything is lost. Always persist important data to a file.

**Hardcoding values**

Magic numbers and hardcoded paths make code fragile. Use constants at the top of the file (like `DATA_FILE = "expenses.csv"`) so they are easy to find and change.

## Summary

In this chapter, you learned:

- A complete application combines many individual concepts: data structures, functions, file I/O, error handling, modules, and classes
- Planning the project structure before writing code saves time and produces cleaner results
- Separating concerns — data model, storage, user interface — makes code easier to understand and modify
- The menu-loop pattern is a standard approach for command-line applications
- Every concept from this course has a natural place in a real project

**Key design pattern:**

```python
# Project structure
# main.py     — entry point, menu loop, user interaction
# model.py    — classes that represent your data
# storage.py  — functions that read/write data to files

# Menu loop pattern
def main():
    data = load_data(filepath)
    while True:
        choice = get_menu_choice()
        if choice == "1":
            action_one(data)
        elif choice == "quit":
            save_data(filepath, data)
            break

main()
```

## Next: Hands-on practice

You are now ready to apply these concepts in **Lab 4.3: Capstone — build a complete application**.

In this lab, you will:

- Set up a new project with uv and `pyproject.toml`
- Create an `Expense` class with attributes and a `__str__` method
- Implement CSV reading and writing for persistent storage
- Build a menu-driven interface with input validation and error handling
- Organize your code across multiple files with proper imports

Open your editor and proceed to Lab 4.3.
